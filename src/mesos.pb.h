// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos.proto

#ifndef PROTOBUF_mesos_2eproto__INCLUDED
#define PROTOBUF_mesos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace mesos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2eproto();
void protobuf_AssignDesc_mesos_2eproto();
void protobuf_ShutdownFile_mesos_2eproto();

class FrameworkID;
class OfferID;
class SlaveID;
class TaskID;
class ExecutorID;
class Param;
class Params;
class Resource;
class Resource_Scalar;
class Resource_Range;
class Resource_Ranges;
class Resource_Set;
class ExecutorArgs;
class TaskDescription;
class TaskStatus;
class ExecutorInfo;
class FrameworkInfo;
class SlaveInfo;
class ResourceRequest;
class Offer;
class Filters;

enum Resource_Type {
  Resource_Type_SCALAR = 0,
  Resource_Type_RANGES = 1,
  Resource_Type_SET = 2
};
bool Resource_Type_IsValid(int value);
const Resource_Type Resource_Type_Type_MIN = Resource_Type_SCALAR;
const Resource_Type Resource_Type_Type_MAX = Resource_Type_SET;
const int Resource_Type_Type_ARRAYSIZE = Resource_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Resource_Type_descriptor();
inline const ::std::string& Resource_Type_Name(Resource_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Resource_Type_descriptor(), value);
}
inline bool Resource_Type_Parse(
    const ::std::string& name, Resource_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Resource_Type>(
    Resource_Type_descriptor(), name, value);
}
enum TaskState {
  TASK_STARTING = 0,
  TASK_RUNNING = 1,
  TASK_FINISHED = 2,
  TASK_FAILED = 3,
  TASK_KILLED = 4,
  TASK_LOST = 5
};
bool TaskState_IsValid(int value);
const TaskState TaskState_MIN = TASK_STARTING;
const TaskState TaskState_MAX = TASK_LOST;
const int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskState_descriptor();
inline const ::std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskState_descriptor(), value);
}
inline bool TaskState_Parse(
    const ::std::string& name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
enum Status {
  OK = 0,
  DRIVER_NOT_RUNNING = 1,
  DRIVER_ALREADY_RUNNING = 2,
  DRIVER_ABORTED = 3,
  DRIVER_STOPPED = 4
};
bool Status_IsValid(int value);
const Status Status_MIN = OK;
const Status Status_MAX = DRIVER_STOPPED;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class FrameworkID : public ::google::protobuf::Message {
 public:
  FrameworkID();
  virtual ~FrameworkID();
  
  FrameworkID(const FrameworkID& from);
  
  inline FrameworkID& operator=(const FrameworkID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkID& default_instance();
  
  void Swap(FrameworkID* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkID& from);
  void MergeFrom(const FrameworkID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:mesos.FrameworkID)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FrameworkID* default_instance_;
};
// -------------------------------------------------------------------

class OfferID : public ::google::protobuf::Message {
 public:
  OfferID();
  virtual ~OfferID();
  
  OfferID(const OfferID& from);
  
  inline OfferID& operator=(const OfferID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferID& default_instance();
  
  void Swap(OfferID* other);
  
  // implements Message ----------------------------------------------
  
  OfferID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferID& from);
  void MergeFrom(const OfferID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:mesos.OfferID)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OfferID* default_instance_;
};
// -------------------------------------------------------------------

class SlaveID : public ::google::protobuf::Message {
 public:
  SlaveID();
  virtual ~SlaveID();
  
  SlaveID(const SlaveID& from);
  
  inline SlaveID& operator=(const SlaveID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveID& default_instance();
  
  void Swap(SlaveID* other);
  
  // implements Message ----------------------------------------------
  
  SlaveID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveID& from);
  void MergeFrom(const SlaveID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:mesos.SlaveID)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SlaveID* default_instance_;
};
// -------------------------------------------------------------------

class TaskID : public ::google::protobuf::Message {
 public:
  TaskID();
  virtual ~TaskID();
  
  TaskID(const TaskID& from);
  
  inline TaskID& operator=(const TaskID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskID& default_instance();
  
  void Swap(TaskID* other);
  
  // implements Message ----------------------------------------------
  
  TaskID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskID& from);
  void MergeFrom(const TaskID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:mesos.TaskID)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TaskID* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorID : public ::google::protobuf::Message {
 public:
  ExecutorID();
  virtual ~ExecutorID();
  
  ExecutorID(const ExecutorID& from);
  
  inline ExecutorID& operator=(const ExecutorID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorID& default_instance();
  
  void Swap(ExecutorID* other);
  
  // implements Message ----------------------------------------------
  
  ExecutorID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorID& from);
  void MergeFrom(const ExecutorID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:mesos.ExecutorID)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecutorID* default_instance_;
};
// -------------------------------------------------------------------

class Param : public ::google::protobuf::Message {
 public:
  Param();
  virtual ~Param();
  
  Param(const Param& from);
  
  inline Param& operator=(const Param& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Param& default_instance();
  
  void Swap(Param* other);
  
  // implements Message ----------------------------------------------
  
  Param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Param& from);
  void MergeFrom(const Param& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:mesos.Param)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Param* default_instance_;
};
// -------------------------------------------------------------------

class Params : public ::google::protobuf::Message {
 public:
  Params();
  virtual ~Params();
  
  Params(const Params& from);
  
  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Params& default_instance();
  
  void Swap(Params* other);
  
  // implements Message ----------------------------------------------
  
  Params* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Params& from);
  void MergeFrom(const Params& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .mesos.Param param = 1;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::mesos::Param& param(int index) const;
  inline ::mesos::Param* mutable_param(int index);
  inline ::mesos::Param* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Param >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Param >*
      mutable_param();
  
  // @@protoc_insertion_point(class_scope:mesos.Params)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::mesos::Param > param_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Params* default_instance_;
};
// -------------------------------------------------------------------

class Resource_Scalar : public ::google::protobuf::Message {
 public:
  Resource_Scalar();
  virtual ~Resource_Scalar();
  
  Resource_Scalar(const Resource_Scalar& from);
  
  inline Resource_Scalar& operator=(const Resource_Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_Scalar& default_instance();
  
  void Swap(Resource_Scalar* other);
  
  // implements Message ----------------------------------------------
  
  Resource_Scalar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_Scalar& from);
  void MergeFrom(const Resource_Scalar& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);
  
  // @@protoc_insertion_point(class_scope:mesos.Resource.Scalar)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Resource_Scalar* default_instance_;
};
// -------------------------------------------------------------------

class Resource_Range : public ::google::protobuf::Message {
 public:
  Resource_Range();
  virtual ~Resource_Range();
  
  Resource_Range(const Resource_Range& from);
  
  inline Resource_Range& operator=(const Resource_Range& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_Range& default_instance();
  
  void Swap(Resource_Range* other);
  
  // implements Message ----------------------------------------------
  
  Resource_Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_Range& from);
  void MergeFrom(const Resource_Range& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::uint64 begin() const;
  inline void set_begin(::google::protobuf::uint64 value);
  
  // required uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:mesos.Resource.Range)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 begin_;
  ::google::protobuf::uint64 end_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Resource_Range* default_instance_;
};
// -------------------------------------------------------------------

class Resource_Ranges : public ::google::protobuf::Message {
 public:
  Resource_Ranges();
  virtual ~Resource_Ranges();
  
  Resource_Ranges(const Resource_Ranges& from);
  
  inline Resource_Ranges& operator=(const Resource_Ranges& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_Ranges& default_instance();
  
  void Swap(Resource_Ranges* other);
  
  // implements Message ----------------------------------------------
  
  Resource_Ranges* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_Ranges& from);
  void MergeFrom(const Resource_Ranges& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .mesos.Resource.Range range = 1;
  inline int range_size() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline const ::mesos::Resource_Range& range(int index) const;
  inline ::mesos::Resource_Range* mutable_range(int index);
  inline ::mesos::Resource_Range* add_range();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource_Range >&
      range() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource_Range >*
      mutable_range();
  
  // @@protoc_insertion_point(class_scope:mesos.Resource.Ranges)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource_Range > range_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Resource_Ranges* default_instance_;
};
// -------------------------------------------------------------------

class Resource_Set : public ::google::protobuf::Message {
 public:
  Resource_Set();
  virtual ~Resource_Set();
  
  Resource_Set(const Resource_Set& from);
  
  inline Resource_Set& operator=(const Resource_Set& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_Set& default_instance();
  
  void Swap(Resource_Set* other);
  
  // implements Message ----------------------------------------------
  
  Resource_Set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_Set& from);
  void MergeFrom(const Resource_Set& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::std::string& item(int index) const;
  inline ::std::string* mutable_item(int index);
  inline void set_item(int index, const ::std::string& value);
  inline void set_item(int index, const char* value);
  inline void set_item(int index, const char* value, size_t size);
  inline ::std::string* add_item();
  inline void add_item(const ::std::string& value);
  inline void add_item(const char* value);
  inline void add_item(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item();
  
  // @@protoc_insertion_point(class_scope:mesos.Resource.Set)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> item_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Resource_Set* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message {
 public:
  Resource();
  virtual ~Resource();
  
  Resource(const Resource& from);
  
  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();
  
  void Swap(Resource* other);
  
  // implements Message ----------------------------------------------
  
  Resource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Resource_Scalar Scalar;
  typedef Resource_Range Range;
  typedef Resource_Ranges Ranges;
  typedef Resource_Set Set;
  
  typedef Resource_Type Type;
  static const Type SCALAR = Resource_Type_SCALAR;
  static const Type RANGES = Resource_Type_RANGES;
  static const Type SET = Resource_Type_SET;
  static inline bool Type_IsValid(int value) {
    return Resource_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Resource_Type_Type_MIN;
  static const Type Type_MAX =
    Resource_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Resource_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Resource_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Resource_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Resource_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .mesos.Resource.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Resource_Type type() const;
  inline void set_type(::mesos::Resource_Type value);
  
  // optional .mesos.Resource.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Resource_Scalar& scalar() const;
  inline ::mesos::Resource_Scalar* mutable_scalar();
  
  // optional .mesos.Resource.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Resource_Ranges& ranges() const;
  inline ::mesos::Resource_Ranges* mutable_ranges();
  
  // optional .mesos.Resource.Set set = 5;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 5;
  inline const ::mesos::Resource_Set& set() const;
  inline ::mesos::Resource_Set* mutable_set();
  
  // @@protoc_insertion_point(class_scope:mesos.Resource)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  int type_;
  ::mesos::Resource_Scalar* scalar_;
  ::mesos::Resource_Ranges* ranges_;
  ::mesos::Resource_Set* set_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorArgs : public ::google::protobuf::Message {
 public:
  ExecutorArgs();
  virtual ~ExecutorArgs();
  
  ExecutorArgs(const ExecutorArgs& from);
  
  inline ExecutorArgs& operator=(const ExecutorArgs& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorArgs& default_instance();
  
  void Swap(ExecutorArgs* other);
  
  // implements Message ----------------------------------------------
  
  ExecutorArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorArgs& from);
  void MergeFrom(const ExecutorArgs& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  
  // optional bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:mesos.ExecutorArgs)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  ::std::string* hostname_;
  static const ::std::string _default_hostname_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecutorArgs* default_instance_;
};
// -------------------------------------------------------------------

class TaskDescription : public ::google::protobuf::Message {
 public:
  TaskDescription();
  virtual ~TaskDescription();
  
  TaskDescription(const TaskDescription& from);
  
  inline TaskDescription& operator=(const TaskDescription& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskDescription& default_instance();
  
  void Swap(TaskDescription* other);
  
  // implements Message ----------------------------------------------
  
  TaskDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskDescription& from);
  void MergeFrom(const TaskDescription& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  
  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // repeated .mesos.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // optional .mesos.ExecutorInfo executor = 5;
  inline bool has_executor() const;
  inline void clear_executor();
  static const int kExecutorFieldNumber = 5;
  inline const ::mesos::ExecutorInfo& executor() const;
  inline ::mesos::ExecutorInfo* mutable_executor();
  
  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:mesos.TaskDescription)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::ExecutorInfo* executor_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TaskDescription* default_instance_;
};
// -------------------------------------------------------------------

class TaskStatus : public ::google::protobuf::Message {
 public:
  TaskStatus();
  virtual ~TaskStatus();
  
  TaskStatus(const TaskStatus& from);
  
  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskStatus& default_instance();
  
  void Swap(TaskStatus* other);
  
  // implements Message ----------------------------------------------
  
  TaskStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskStatus& from);
  void MergeFrom(const TaskStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  
  // required .mesos.TaskState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline mesos::TaskState state() const;
  inline void set_state(mesos::TaskState value);
  
  // optional string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:mesos.TaskStatus)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::TaskID* task_id_;
  int state_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TaskStatus* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorInfo : public ::google::protobuf::Message {
 public:
  ExecutorInfo();
  virtual ~ExecutorInfo();
  
  ExecutorInfo(const ExecutorInfo& from);
  
  inline ExecutorInfo& operator=(const ExecutorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorInfo& default_instance();
  
  void Swap(ExecutorInfo* other);
  
  // implements Message ----------------------------------------------
  
  ExecutorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorInfo& from);
  void MergeFrom(const ExecutorInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // required string uri = 2;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 2;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  
  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // optional .mesos.Params params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::mesos::Params& params() const;
  inline ::mesos::Params* mutable_params();
  
  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:mesos.ExecutorInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::ExecutorID* executor_id_;
  ::std::string* uri_;
  static const ::std::string _default_uri_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::Params* params_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecutorInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInfo : public ::google::protobuf::Message {
 public:
  FrameworkInfo();
  virtual ~FrameworkInfo();
  
  FrameworkInfo(const FrameworkInfo& from);
  
  inline FrameworkInfo& operator=(const FrameworkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo& default_instance();
  
  void Swap(FrameworkInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInfo& from);
  void MergeFrom(const FrameworkInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .mesos.ExecutorInfo executor = 3;
  inline bool has_executor() const;
  inline void clear_executor();
  static const int kExecutorFieldNumber = 3;
  inline const ::mesos::ExecutorInfo& executor() const;
  inline ::mesos::ExecutorInfo* mutable_executor();
  
  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* user_;
  static const ::std::string _default_user_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::mesos::ExecutorInfo* executor_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FrameworkInfo* default_instance_;
};
// -------------------------------------------------------------------

class SlaveInfo : public ::google::protobuf::Message {
 public:
  SlaveInfo();
  virtual ~SlaveInfo();
  
  SlaveInfo(const SlaveInfo& from);
  
  inline SlaveInfo& operator=(const SlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo& default_instance();
  
  void Swap(SlaveInfo* other);
  
  // implements Message ----------------------------------------------
  
  SlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveInfo& from);
  void MergeFrom(const SlaveInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  
  // required string public_hostname = 2;
  inline bool has_public_hostname() const;
  inline void clear_public_hostname();
  static const int kPublicHostnameFieldNumber = 2;
  inline const ::std::string& public_hostname() const;
  inline void set_public_hostname(const ::std::string& value);
  inline void set_public_hostname(const char* value);
  inline void set_public_hostname(const char* value, size_t size);
  inline ::std::string* mutable_public_hostname();
  
  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* hostname_;
  static const ::std::string _default_hostname_;
  ::std::string* public_hostname_;
  static const ::std::string _default_public_hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceRequest : public ::google::protobuf::Message {
 public:
  ResourceRequest();
  virtual ~ResourceRequest();
  
  ResourceRequest(const ResourceRequest& from);
  
  inline ResourceRequest& operator=(const ResourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceRequest& default_instance();
  
  void Swap(ResourceRequest* other);
  
  // implements Message ----------------------------------------------
  
  ResourceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceRequest& from);
  void MergeFrom(const ResourceRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // repeated .mesos.Resource resources = 2;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 2;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // @@protoc_insertion_point(class_scope:mesos.ResourceRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResourceRequest* default_instance_;
};
// -------------------------------------------------------------------

class Offer : public ::google::protobuf::Message {
 public:
  Offer();
  virtual ~Offer();
  
  Offer(const Offer& from);
  
  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer& default_instance();
  
  void Swap(Offer* other);
  
  // implements Message ----------------------------------------------
  
  Offer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.OfferID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mesos::OfferID& id() const;
  inline ::mesos::OfferID* mutable_id();
  
  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  
  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // repeated .mesos.ExecutorID executor_ids = 6;
  inline int executor_ids_size() const;
  inline void clear_executor_ids();
  static const int kExecutorIdsFieldNumber = 6;
  inline const ::mesos::ExecutorID& executor_ids(int index) const;
  inline ::mesos::ExecutorID* mutable_executor_ids(int index);
  inline ::mesos::ExecutorID* add_executor_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
      executor_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
      mutable_executor_ids();
  
  // @@protoc_insertion_point(class_scope:mesos.Offer)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::OfferID* id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::std::string* hostname_;
  static const ::std::string _default_hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID > executor_ids_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Offer* default_instance_;
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::Message {
 public:
  Filters();
  virtual ~Filters();
  
  Filters(const Filters& from);
  
  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Filters& default_instance();
  
  void Swap(Filters* other);
  
  // implements Message ----------------------------------------------
  
  Filters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double refuse_seconds = 1;
  inline bool has_refuse_seconds() const;
  inline void clear_refuse_seconds();
  static const int kRefuseSecondsFieldNumber = 1;
  inline double refuse_seconds() const;
  inline void set_refuse_seconds(double value);
  
  // @@protoc_insertion_point(class_scope:mesos.Filters)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double refuse_seconds_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Filters* default_instance_;
};
// ===================================================================


// ===================================================================

// FrameworkID

// required string value = 1;
inline bool FrameworkID::has_value() const {
  return _has_bit(0);
}
inline void FrameworkID::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FrameworkID::value() const {
  return *value_;
}
inline void FrameworkID::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkID::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// OfferID

// required string value = 1;
inline bool OfferID::has_value() const {
  return _has_bit(0);
}
inline void OfferID::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OfferID::value() const {
  return *value_;
}
inline void OfferID::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferID::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// SlaveID

// required string value = 1;
inline bool SlaveID::has_value() const {
  return _has_bit(0);
}
inline void SlaveID::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SlaveID::value() const {
  return *value_;
}
inline void SlaveID::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveID::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// TaskID

// required string value = 1;
inline bool TaskID::has_value() const {
  return _has_bit(0);
}
inline void TaskID::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TaskID::value() const {
  return *value_;
}
inline void TaskID::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskID::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// ExecutorID

// required string value = 1;
inline bool ExecutorID::has_value() const {
  return _has_bit(0);
}
inline void ExecutorID::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ExecutorID::value() const {
  return *value_;
}
inline void ExecutorID::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorID::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// Param

// required string key = 1;
inline bool Param::has_key() const {
  return _has_bit(0);
}
inline void Param::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Param::key() const {
  return *key_;
}
inline void Param::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Param::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Param::set_key(const char* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Param::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required string value = 2;
inline bool Param::has_value() const {
  return _has_bit(1);
}
inline void Param::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Param::value() const {
  return *value_;
}
inline void Param::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Param::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Param::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Param::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// Params

// repeated .mesos.Param param = 1;
inline int Params::param_size() const {
  return param_.size();
}
inline void Params::clear_param() {
  param_.Clear();
}
inline const ::mesos::Param& Params::param(int index) const {
  return param_.Get(index);
}
inline ::mesos::Param* Params::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::mesos::Param* Params::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Param >&
Params::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Param >*
Params::mutable_param() {
  return &param_;
}

// -------------------------------------------------------------------

// Resource_Scalar

// required double value = 1;
inline bool Resource_Scalar::has_value() const {
  return _has_bit(0);
}
inline void Resource_Scalar::clear_value() {
  value_ = 0;
  _clear_bit(0);
}
inline double Resource_Scalar::value() const {
  return value_;
}
inline void Resource_Scalar::set_value(double value) {
  _set_bit(0);
  value_ = value;
}

// -------------------------------------------------------------------

// Resource_Range

// required uint64 begin = 1;
inline bool Resource_Range::has_begin() const {
  return _has_bit(0);
}
inline void Resource_Range::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 Resource_Range::begin() const {
  return begin_;
}
inline void Resource_Range::set_begin(::google::protobuf::uint64 value) {
  _set_bit(0);
  begin_ = value;
}

// required uint64 end = 2;
inline bool Resource_Range::has_end() const {
  return _has_bit(1);
}
inline void Resource_Range::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 Resource_Range::end() const {
  return end_;
}
inline void Resource_Range::set_end(::google::protobuf::uint64 value) {
  _set_bit(1);
  end_ = value;
}

// -------------------------------------------------------------------

// Resource_Ranges

// repeated .mesos.Resource.Range range = 1;
inline int Resource_Ranges::range_size() const {
  return range_.size();
}
inline void Resource_Ranges::clear_range() {
  range_.Clear();
}
inline const ::mesos::Resource_Range& Resource_Ranges::range(int index) const {
  return range_.Get(index);
}
inline ::mesos::Resource_Range* Resource_Ranges::mutable_range(int index) {
  return range_.Mutable(index);
}
inline ::mesos::Resource_Range* Resource_Ranges::add_range() {
  return range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource_Range >&
Resource_Ranges::range() const {
  return range_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource_Range >*
Resource_Ranges::mutable_range() {
  return &range_;
}

// -------------------------------------------------------------------

// Resource_Set

// repeated string item = 1;
inline int Resource_Set::item_size() const {
  return item_.size();
}
inline void Resource_Set::clear_item() {
  item_.Clear();
}
inline const ::std::string& Resource_Set::item(int index) const {
  return item_.Get(index);
}
inline ::std::string* Resource_Set::mutable_item(int index) {
  return item_.Mutable(index);
}
inline void Resource_Set::set_item(int index, const ::std::string& value) {
  item_.Mutable(index)->assign(value);
}
inline void Resource_Set::set_item(int index, const char* value) {
  item_.Mutable(index)->assign(value);
}
inline void Resource_Set::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource_Set::add_item() {
  return item_.Add();
}
inline void Resource_Set::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
}
inline void Resource_Set::add_item(const char* value) {
  item_.Add()->assign(value);
}
inline void Resource_Set::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Resource_Set::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Resource_Set::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// Resource

// required string name = 1;
inline bool Resource::has_name() const {
  return _has_bit(0);
}
inline void Resource::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Resource::name() const {
  return *name_;
}
inline void Resource::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .mesos.Resource.Type type = 2;
inline bool Resource::has_type() const {
  return _has_bit(1);
}
inline void Resource::clear_type() {
  type_ = 0;
  _clear_bit(1);
}
inline ::mesos::Resource_Type Resource::type() const {
  return static_cast< ::mesos::Resource_Type >(type_);
}
inline void Resource::set_type(::mesos::Resource_Type value) {
  GOOGLE_DCHECK(::mesos::Resource_Type_IsValid(value));
  _set_bit(1);
  type_ = value;
}

// optional .mesos.Resource.Scalar scalar = 3;
inline bool Resource::has_scalar() const {
  return _has_bit(2);
}
inline void Resource::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Resource_Scalar::Clear();
  _clear_bit(2);
}
inline const ::mesos::Resource_Scalar& Resource::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Resource_Scalar* Resource::mutable_scalar() {
  _set_bit(2);
  if (scalar_ == NULL) scalar_ = new ::mesos::Resource_Scalar;
  return scalar_;
}

// optional .mesos.Resource.Ranges ranges = 4;
inline bool Resource::has_ranges() const {
  return _has_bit(3);
}
inline void Resource::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Resource_Ranges::Clear();
  _clear_bit(3);
}
inline const ::mesos::Resource_Ranges& Resource::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Resource_Ranges* Resource::mutable_ranges() {
  _set_bit(3);
  if (ranges_ == NULL) ranges_ = new ::mesos::Resource_Ranges;
  return ranges_;
}

// optional .mesos.Resource.Set set = 5;
inline bool Resource::has_set() const {
  return _has_bit(4);
}
inline void Resource::clear_set() {
  if (set_ != NULL) set_->::mesos::Resource_Set::Clear();
  _clear_bit(4);
}
inline const ::mesos::Resource_Set& Resource::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Resource_Set* Resource::mutable_set() {
  _set_bit(4);
  if (set_ == NULL) set_ = new ::mesos::Resource_Set;
  return set_;
}

// -------------------------------------------------------------------

// ExecutorArgs

// required .mesos.FrameworkID framework_id = 1;
inline bool ExecutorArgs::has_framework_id() const {
  return _has_bit(0);
}
inline void ExecutorArgs::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& ExecutorArgs::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorArgs::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.ExecutorID executor_id = 2;
inline bool ExecutorArgs::has_executor_id() const {
  return _has_bit(1);
}
inline void ExecutorArgs::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(1);
}
inline const ::mesos::ExecutorID& ExecutorArgs::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorArgs::mutable_executor_id() {
  _set_bit(1);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// required .mesos.SlaveID slave_id = 3;
inline bool ExecutorArgs::has_slave_id() const {
  return _has_bit(2);
}
inline void ExecutorArgs::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(2);
}
inline const ::mesos::SlaveID& ExecutorArgs::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ExecutorArgs::mutable_slave_id() {
  _set_bit(2);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required string hostname = 4;
inline bool ExecutorArgs::has_hostname() const {
  return _has_bit(3);
}
inline void ExecutorArgs::clear_hostname() {
  if (hostname_ != &_default_hostname_) {
    hostname_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& ExecutorArgs::hostname() const {
  return *hostname_;
}
inline void ExecutorArgs::set_hostname(const ::std::string& value) {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ExecutorArgs::set_hostname(const char* value) {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ExecutorArgs::set_hostname(const char* value, size_t size) {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorArgs::mutable_hostname() {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}

// optional bytes data = 5;
inline bool ExecutorArgs::has_data() const {
  return _has_bit(4);
}
inline void ExecutorArgs::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ExecutorArgs::data() const {
  return *data_;
}
inline void ExecutorArgs::set_data(const ::std::string& value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorArgs::set_data(const char* value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorArgs::set_data(const void* value, size_t size) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorArgs::mutable_data() {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// TaskDescription

// required string name = 1;
inline bool TaskDescription::has_name() const {
  return _has_bit(0);
}
inline void TaskDescription::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TaskDescription::name() const {
  return *name_;
}
inline void TaskDescription::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskDescription::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskDescription::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskDescription::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .mesos.TaskID task_id = 2;
inline bool TaskDescription::has_task_id() const {
  return _has_bit(1);
}
inline void TaskDescription::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  _clear_bit(1);
}
inline const ::mesos::TaskID& TaskDescription::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskDescription::mutable_task_id() {
  _set_bit(1);
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}

// required .mesos.SlaveID slave_id = 3;
inline bool TaskDescription::has_slave_id() const {
  return _has_bit(2);
}
inline void TaskDescription::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(2);
}
inline const ::mesos::SlaveID& TaskDescription::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskDescription::mutable_slave_id() {
  _set_bit(2);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// repeated .mesos.Resource resources = 4;
inline int TaskDescription::resources_size() const {
  return resources_.size();
}
inline void TaskDescription::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskDescription::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskDescription::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskDescription::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskDescription::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskDescription::mutable_resources() {
  return &resources_;
}

// optional .mesos.ExecutorInfo executor = 5;
inline bool TaskDescription::has_executor() const {
  return _has_bit(4);
}
inline void TaskDescription::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  _clear_bit(4);
}
inline const ::mesos::ExecutorInfo& TaskDescription::executor() const {
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
inline ::mesos::ExecutorInfo* TaskDescription::mutable_executor() {
  _set_bit(4);
  if (executor_ == NULL) executor_ = new ::mesos::ExecutorInfo;
  return executor_;
}

// optional bytes data = 6;
inline bool TaskDescription::has_data() const {
  return _has_bit(5);
}
inline void TaskDescription::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& TaskDescription::data() const {
  return *data_;
}
inline void TaskDescription::set_data(const ::std::string& value) {
  _set_bit(5);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskDescription::set_data(const char* value) {
  _set_bit(5);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskDescription::set_data(const void* value, size_t size) {
  _set_bit(5);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskDescription::mutable_data() {
  _set_bit(5);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// TaskStatus

// required .mesos.TaskID task_id = 1;
inline bool TaskStatus::has_task_id() const {
  return _has_bit(0);
}
inline void TaskStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  _clear_bit(0);
}
inline const ::mesos::TaskID& TaskStatus::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskStatus::mutable_task_id() {
  _set_bit(0);
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}

// required .mesos.TaskState state = 2;
inline bool TaskStatus::has_state() const {
  return _has_bit(1);
}
inline void TaskStatus::clear_state() {
  state_ = 0;
  _clear_bit(1);
}
inline mesos::TaskState TaskStatus::state() const {
  return static_cast< mesos::TaskState >(state_);
}
inline void TaskStatus::set_state(mesos::TaskState value) {
  GOOGLE_DCHECK(mesos::TaskState_IsValid(value));
  _set_bit(1);
  state_ = value;
}

// optional string message = 4;
inline bool TaskStatus::has_message() const {
  return _has_bit(2);
}
inline void TaskStatus::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& TaskStatus::message() const {
  return *message_;
}
inline void TaskStatus::set_message(const ::std::string& value) {
  _set_bit(2);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value) {
  _set_bit(2);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value, size_t size) {
  _set_bit(2);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_message() {
  _set_bit(2);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// optional bytes data = 3;
inline bool TaskStatus::has_data() const {
  return _has_bit(3);
}
inline void TaskStatus::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& TaskStatus::data() const {
  return *data_;
}
inline void TaskStatus::set_data(const ::std::string& value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const char* value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const void* value, size_t size) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_data() {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// ExecutorInfo

// required .mesos.ExecutorID executor_id = 1;
inline bool ExecutorInfo::has_executor_id() const {
  return _has_bit(0);
}
inline void ExecutorInfo::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(0);
}
inline const ::mesos::ExecutorID& ExecutorInfo::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::mutable_executor_id() {
  _set_bit(0);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// required string uri = 2;
inline bool ExecutorInfo::has_uri() const {
  return _has_bit(1);
}
inline void ExecutorInfo::clear_uri() {
  if (uri_ != &_default_uri_) {
    uri_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ExecutorInfo::uri() const {
  return *uri_;
}
inline void ExecutorInfo::set_uri(const ::std::string& value) {
  _set_bit(1);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void ExecutorInfo::set_uri(const char* value) {
  _set_bit(1);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void ExecutorInfo::set_uri(const char* value, size_t size) {
  _set_bit(1);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_uri() {
  _set_bit(1);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  return uri_;
}

// repeated .mesos.Resource resources = 5;
inline int ExecutorInfo::resources_size() const {
  return resources_.size();
}
inline void ExecutorInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ExecutorInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* ExecutorInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ExecutorInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ExecutorInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ExecutorInfo::mutable_resources() {
  return &resources_;
}

// optional .mesos.Params params = 3;
inline bool ExecutorInfo::has_params() const {
  return _has_bit(3);
}
inline void ExecutorInfo::clear_params() {
  if (params_ != NULL) params_->::mesos::Params::Clear();
  _clear_bit(3);
}
inline const ::mesos::Params& ExecutorInfo::params() const {
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::mesos::Params* ExecutorInfo::mutable_params() {
  _set_bit(3);
  if (params_ == NULL) params_ = new ::mesos::Params;
  return params_;
}

// optional bytes data = 4;
inline bool ExecutorInfo::has_data() const {
  return _has_bit(4);
}
inline void ExecutorInfo::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ExecutorInfo::data() const {
  return *data_;
}
inline void ExecutorInfo::set_data(const ::std::string& value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const char* value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const void* value, size_t size) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_data() {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// FrameworkInfo

// required string user = 1;
inline bool FrameworkInfo::has_user() const {
  return _has_bit(0);
}
inline void FrameworkInfo::clear_user() {
  if (user_ != &_default_user_) {
    user_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FrameworkInfo::user() const {
  return *user_;
}
inline void FrameworkInfo::set_user(const ::std::string& value) {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value) {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value, size_t size) {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_user() {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  return user_;
}

// required string name = 2;
inline bool FrameworkInfo::has_name() const {
  return _has_bit(1);
}
inline void FrameworkInfo::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& FrameworkInfo::name() const {
  return *name_;
}
inline void FrameworkInfo::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .mesos.ExecutorInfo executor = 3;
inline bool FrameworkInfo::has_executor() const {
  return _has_bit(2);
}
inline void FrameworkInfo::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  _clear_bit(2);
}
inline const ::mesos::ExecutorInfo& FrameworkInfo::executor() const {
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
inline ::mesos::ExecutorInfo* FrameworkInfo::mutable_executor() {
  _set_bit(2);
  if (executor_ == NULL) executor_ = new ::mesos::ExecutorInfo;
  return executor_;
}

// -------------------------------------------------------------------

// SlaveInfo

// required string hostname = 1;
inline bool SlaveInfo::has_hostname() const {
  return _has_bit(0);
}
inline void SlaveInfo::clear_hostname() {
  if (hostname_ != &_default_hostname_) {
    hostname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SlaveInfo::hostname() const {
  return *hostname_;
}
inline void SlaveInfo::set_hostname(const ::std::string& value) {
  _set_bit(0);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value) {
  _set_bit(0);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value, size_t size) {
  _set_bit(0);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveInfo::mutable_hostname() {
  _set_bit(0);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}

// required string public_hostname = 2;
inline bool SlaveInfo::has_public_hostname() const {
  return _has_bit(1);
}
inline void SlaveInfo::clear_public_hostname() {
  if (public_hostname_ != &_default_public_hostname_) {
    public_hostname_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SlaveInfo::public_hostname() const {
  return *public_hostname_;
}
inline void SlaveInfo::set_public_hostname(const ::std::string& value) {
  _set_bit(1);
  if (public_hostname_ == &_default_public_hostname_) {
    public_hostname_ = new ::std::string;
  }
  public_hostname_->assign(value);
}
inline void SlaveInfo::set_public_hostname(const char* value) {
  _set_bit(1);
  if (public_hostname_ == &_default_public_hostname_) {
    public_hostname_ = new ::std::string;
  }
  public_hostname_->assign(value);
}
inline void SlaveInfo::set_public_hostname(const char* value, size_t size) {
  _set_bit(1);
  if (public_hostname_ == &_default_public_hostname_) {
    public_hostname_ = new ::std::string;
  }
  public_hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveInfo::mutable_public_hostname() {
  _set_bit(1);
  if (public_hostname_ == &_default_public_hostname_) {
    public_hostname_ = new ::std::string;
  }
  return public_hostname_;
}

// repeated .mesos.Resource resources = 3;
inline int SlaveInfo::resources_size() const {
  return resources_.size();
}
inline void SlaveInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& SlaveInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* SlaveInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* SlaveInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
SlaveInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
SlaveInfo::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// ResourceRequest

// optional .mesos.SlaveID slave_id = 1;
inline bool ResourceRequest::has_slave_id() const {
  return _has_bit(0);
}
inline void ResourceRequest::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& ResourceRequest::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ResourceRequest::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// repeated .mesos.Resource resources = 2;
inline int ResourceRequest::resources_size() const {
  return resources_.size();
}
inline void ResourceRequest::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ResourceRequest::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* ResourceRequest::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ResourceRequest::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceRequest::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceRequest::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// Offer

// required .mesos.OfferID id = 1;
inline bool Offer::has_id() const {
  return _has_bit(0);
}
inline void Offer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  _clear_bit(0);
}
inline const ::mesos::OfferID& Offer::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::OfferID* Offer::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::mesos::OfferID;
  return id_;
}

// required .mesos.FrameworkID framework_id = 2;
inline bool Offer::has_framework_id() const {
  return _has_bit(1);
}
inline void Offer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(1);
}
inline const ::mesos::FrameworkID& Offer::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Offer::mutable_framework_id() {
  _set_bit(1);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.SlaveID slave_id = 3;
inline bool Offer::has_slave_id() const {
  return _has_bit(2);
}
inline void Offer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(2);
}
inline const ::mesos::SlaveID& Offer::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Offer::mutable_slave_id() {
  _set_bit(2);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required string hostname = 4;
inline bool Offer::has_hostname() const {
  return _has_bit(3);
}
inline void Offer::clear_hostname() {
  if (hostname_ != &_default_hostname_) {
    hostname_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Offer::hostname() const {
  return *hostname_;
}
inline void Offer::set_hostname(const ::std::string& value) {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value) {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value, size_t size) {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Offer::mutable_hostname() {
  _set_bit(3);
  if (hostname_ == &_default_hostname_) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}

// repeated .mesos.Resource resources = 5;
inline int Offer::resources_size() const {
  return resources_.size();
}
inline void Offer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer::mutable_resources() {
  return &resources_;
}

// repeated .mesos.ExecutorID executor_ids = 6;
inline int Offer::executor_ids_size() const {
  return executor_ids_.size();
}
inline void Offer::clear_executor_ids() {
  executor_ids_.Clear();
}
inline const ::mesos::ExecutorID& Offer::executor_ids(int index) const {
  return executor_ids_.Get(index);
}
inline ::mesos::ExecutorID* Offer::mutable_executor_ids(int index) {
  return executor_ids_.Mutable(index);
}
inline ::mesos::ExecutorID* Offer::add_executor_ids() {
  return executor_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
Offer::executor_ids() const {
  return executor_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
Offer::mutable_executor_ids() {
  return &executor_ids_;
}

// -------------------------------------------------------------------

// Filters

// optional double refuse_seconds = 1;
inline bool Filters::has_refuse_seconds() const {
  return _has_bit(0);
}
inline void Filters::clear_refuse_seconds() {
  refuse_seconds_ = 0;
  _clear_bit(0);
}
inline double Filters::refuse_seconds() const {
  return refuse_seconds_;
}
inline void Filters::set_refuse_seconds(double value) {
  _set_bit(0);
  refuse_seconds_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Resource_Type>() {
  return ::mesos::Resource_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< mesos::TaskState>() {
  return mesos::TaskState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< mesos::Status>() {
  return mesos::Status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2eproto__INCLUDED
