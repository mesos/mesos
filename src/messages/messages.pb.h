// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {
namespace internal {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Task;
class StatusUpdate;
class SubmitSchedulerRequest;
class SubmitSchedulerResponse;
class ExecutorToFrameworkMessage;
class FrameworkToExecutorMessage;
class RegisterFrameworkMessage;
class ReregisterFrameworkMessage;
class FrameworkRegisteredMessage;
class FrameworkReregisteredMessage;
class UnregisterFrameworkMessage;
class DeactivateFrameworkMessage;
class ResourceRequestMessage;
class ResourceOffersMessage;
class LaunchTasksMessage;
class RescindResourceOfferMessage;
class ReviveOffersMessage;
class RunTaskMessage;
class KillTaskMessage;
class StatusUpdateMessage;
class StatusUpdateAcknowledgementMessage;
class LostSlaveMessage;
class FrameworkErrorMessage;
class RegisterSlaveMessage;
class ReregisterSlaveMessage;
class SlaveRegisteredMessage;
class SlaveReregisteredMessage;
class UnregisterSlaveMessage;
class HeartbeatMessage;
class ShutdownFrameworkMessage;
class ShutdownExecutorMessage;
class UpdateFrameworkMessage;
class RegisterExecutorMessage;
class ExecutorRegisteredMessage;
class ExitedExecutorMessage;
class RegisterProjdMessage;
class ProjdReadyMessage;
class ProjdUpdateResourcesMessage;
class FrameworkExpiredMessage;
class ShutdownMessage;
class NoMasterDetectedMessage;
class NewMasterDetectedMessage;
class GotMasterTokenMessage;

// ===================================================================

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();
  
  Task(const Task& from);
  
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();
  
  void Swap(Task* other);
  
  // implements Message ----------------------------------------------
  
  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  
  // required .mesos.FrameworkID framework_id = 3;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.ExecutorID executor_id = 4;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 4;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // required .mesos.SlaveID slave_id = 5;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required .mesos.TaskState state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline mesos::TaskState state() const;
  inline void set_state(mesos::TaskState value);
  
  // repeated .mesos.Resource resources = 7;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 7;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.Task)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::mesos::TaskID* task_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  int state_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class StatusUpdate : public ::google::protobuf::Message {
 public:
  StatusUpdate();
  virtual ~StatusUpdate();
  
  StatusUpdate(const StatusUpdate& from);
  
  inline StatusUpdate& operator=(const StatusUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdate& default_instance();
  
  void Swap(StatusUpdate* other);
  
  // implements Message ----------------------------------------------
  
  StatusUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusUpdate& from);
  void MergeFrom(const StatusUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // optional .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // optional .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required .mesos.TaskStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::mesos::TaskStatus& status() const;
  inline ::mesos::TaskStatus* mutable_status();
  
  // required double timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline double timestamp() const;
  inline void set_timestamp(double value);
  
  // required bytes uuid = 6;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 6;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.StatusUpdate)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::TaskStatus* status_;
  double timestamp_;
  ::std::string* uuid_;
  static const ::std::string _default_uuid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StatusUpdate* default_instance_;
};
// -------------------------------------------------------------------

class SubmitSchedulerRequest : public ::google::protobuf::Message {
 public:
  SubmitSchedulerRequest();
  virtual ~SubmitSchedulerRequest();
  
  SubmitSchedulerRequest(const SubmitSchedulerRequest& from);
  
  inline SubmitSchedulerRequest& operator=(const SubmitSchedulerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitSchedulerRequest& default_instance();
  
  void Swap(SubmitSchedulerRequest* other);
  
  // implements Message ----------------------------------------------
  
  SubmitSchedulerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitSchedulerRequest& from);
  void MergeFrom(const SubmitSchedulerRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.SubmitSchedulerRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SubmitSchedulerRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubmitSchedulerResponse : public ::google::protobuf::Message {
 public:
  SubmitSchedulerResponse();
  virtual ~SubmitSchedulerResponse();
  
  SubmitSchedulerResponse(const SubmitSchedulerResponse& from);
  
  inline SubmitSchedulerResponse& operator=(const SubmitSchedulerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitSchedulerResponse& default_instance();
  
  void Swap(SubmitSchedulerResponse* other);
  
  // implements Message ----------------------------------------------
  
  SubmitSchedulerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitSchedulerResponse& from);
  void MergeFrom(const SubmitSchedulerResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool okay = 1;
  inline bool has_okay() const;
  inline void clear_okay();
  static const int kOkayFieldNumber = 1;
  inline bool okay() const;
  inline void set_okay(bool value);
  
  // @@protoc_insertion_point(class_scope:mesos.internal.SubmitSchedulerResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool okay_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SubmitSchedulerResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorToFrameworkMessage : public ::google::protobuf::Message {
 public:
  ExecutorToFrameworkMessage();
  virtual ~ExecutorToFrameworkMessage();
  
  ExecutorToFrameworkMessage(const ExecutorToFrameworkMessage& from);
  
  inline ExecutorToFrameworkMessage& operator=(const ExecutorToFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorToFrameworkMessage& default_instance();
  
  void Swap(ExecutorToFrameworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  ExecutorToFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorToFrameworkMessage& from);
  void MergeFrom(const ExecutorToFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ExecutorToFrameworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecutorToFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkToExecutorMessage : public ::google::protobuf::Message {
 public:
  FrameworkToExecutorMessage();
  virtual ~FrameworkToExecutorMessage();
  
  FrameworkToExecutorMessage(const FrameworkToExecutorMessage& from);
  
  inline FrameworkToExecutorMessage& operator=(const FrameworkToExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkToExecutorMessage& default_instance();
  
  void Swap(FrameworkToExecutorMessage* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkToExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkToExecutorMessage& from);
  void MergeFrom(const FrameworkToExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkToExecutorMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FrameworkToExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterFrameworkMessage : public ::google::protobuf::Message {
 public:
  RegisterFrameworkMessage();
  virtual ~RegisterFrameworkMessage();
  
  RegisterFrameworkMessage(const RegisterFrameworkMessage& from);
  
  inline RegisterFrameworkMessage& operator=(const RegisterFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterFrameworkMessage& default_instance();
  
  void Swap(RegisterFrameworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  RegisterFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterFrameworkMessage& from);
  void MergeFrom(const RegisterFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkInfo framework = 1;
  inline bool has_framework() const;
  inline void clear_framework();
  static const int kFrameworkFieldNumber = 1;
  inline const ::mesos::FrameworkInfo& framework() const;
  inline ::mesos::FrameworkInfo* mutable_framework();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.RegisterFrameworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkInfo* framework_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RegisterFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReregisterFrameworkMessage : public ::google::protobuf::Message {
 public:
  ReregisterFrameworkMessage();
  virtual ~ReregisterFrameworkMessage();
  
  ReregisterFrameworkMessage(const ReregisterFrameworkMessage& from);
  
  inline ReregisterFrameworkMessage& operator=(const ReregisterFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReregisterFrameworkMessage& default_instance();
  
  void Swap(ReregisterFrameworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  ReregisterFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReregisterFrameworkMessage& from);
  void MergeFrom(const ReregisterFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.FrameworkInfo framework = 2;
  inline bool has_framework() const;
  inline void clear_framework();
  static const int kFrameworkFieldNumber = 2;
  inline const ::mesos::FrameworkInfo& framework() const;
  inline ::mesos::FrameworkInfo* mutable_framework();
  
  // required bool failover = 3;
  inline bool has_failover() const;
  inline void clear_failover();
  static const int kFailoverFieldNumber = 3;
  inline bool failover() const;
  inline void set_failover(bool value);
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ReregisterFrameworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::mesos::FrameworkInfo* framework_;
  bool failover_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ReregisterFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkRegisteredMessage : public ::google::protobuf::Message {
 public:
  FrameworkRegisteredMessage();
  virtual ~FrameworkRegisteredMessage();
  
  FrameworkRegisteredMessage(const FrameworkRegisteredMessage& from);
  
  inline FrameworkRegisteredMessage& operator=(const FrameworkRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkRegisteredMessage& default_instance();
  
  void Swap(FrameworkRegisteredMessage* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkRegisteredMessage& from);
  void MergeFrom(const FrameworkRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkRegisteredMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FrameworkRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkReregisteredMessage : public ::google::protobuf::Message {
 public:
  FrameworkReregisteredMessage();
  virtual ~FrameworkReregisteredMessage();
  
  FrameworkReregisteredMessage(const FrameworkReregisteredMessage& from);
  
  inline FrameworkReregisteredMessage& operator=(const FrameworkReregisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkReregisteredMessage& default_instance();
  
  void Swap(FrameworkReregisteredMessage* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkReregisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkReregisteredMessage& from);
  void MergeFrom(const FrameworkReregisteredMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkReregisteredMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FrameworkReregisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterFrameworkMessage : public ::google::protobuf::Message {
 public:
  UnregisterFrameworkMessage();
  virtual ~UnregisterFrameworkMessage();
  
  UnregisterFrameworkMessage(const UnregisterFrameworkMessage& from);
  
  inline UnregisterFrameworkMessage& operator=(const UnregisterFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterFrameworkMessage& default_instance();
  
  void Swap(UnregisterFrameworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  UnregisterFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnregisterFrameworkMessage& from);
  void MergeFrom(const UnregisterFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.UnregisterFrameworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UnregisterFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class DeactivateFrameworkMessage : public ::google::protobuf::Message {
 public:
  DeactivateFrameworkMessage();
  virtual ~DeactivateFrameworkMessage();
  
  DeactivateFrameworkMessage(const DeactivateFrameworkMessage& from);
  
  inline DeactivateFrameworkMessage& operator=(const DeactivateFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeactivateFrameworkMessage& default_instance();
  
  void Swap(DeactivateFrameworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  DeactivateFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeactivateFrameworkMessage& from);
  void MergeFrom(const DeactivateFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.DeactivateFrameworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeactivateFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResourceRequestMessage : public ::google::protobuf::Message {
 public:
  ResourceRequestMessage();
  virtual ~ResourceRequestMessage();
  
  ResourceRequestMessage(const ResourceRequestMessage& from);
  
  inline ResourceRequestMessage& operator=(const ResourceRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceRequestMessage& default_instance();
  
  void Swap(ResourceRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  ResourceRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceRequestMessage& from);
  void MergeFrom(const ResourceRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // repeated .mesos.ResourceRequest requests = 2;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 2;
  inline const ::mesos::ResourceRequest& requests(int index) const;
  inline ::mesos::ResourceRequest* mutable_requests(int index);
  inline ::mesos::ResourceRequest* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceRequest >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceRequest >*
      mutable_requests();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ResourceRequestMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ResourceRequest > requests_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResourceRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResourceOffersMessage : public ::google::protobuf::Message {
 public:
  ResourceOffersMessage();
  virtual ~ResourceOffersMessage();
  
  ResourceOffersMessage(const ResourceOffersMessage& from);
  
  inline ResourceOffersMessage& operator=(const ResourceOffersMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceOffersMessage& default_instance();
  
  void Swap(ResourceOffersMessage* other);
  
  // implements Message ----------------------------------------------
  
  ResourceOffersMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceOffersMessage& from);
  void MergeFrom(const ResourceOffersMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .mesos.Offer offers = 1;
  inline int offers_size() const;
  inline void clear_offers();
  static const int kOffersFieldNumber = 1;
  inline const ::mesos::Offer& offers(int index) const;
  inline ::mesos::Offer* mutable_offers(int index);
  inline ::mesos::Offer* add_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
      offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
      mutable_offers();
  
  // repeated string pids = 2;
  inline int pids_size() const;
  inline void clear_pids();
  static const int kPidsFieldNumber = 2;
  inline const ::std::string& pids(int index) const;
  inline ::std::string* mutable_pids(int index);
  inline void set_pids(int index, const ::std::string& value);
  inline void set_pids(int index, const char* value);
  inline void set_pids(int index, const char* value, size_t size);
  inline ::std::string* add_pids();
  inline void add_pids(const ::std::string& value);
  inline void add_pids(const char* value);
  inline void add_pids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pids();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ResourceOffersMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer > offers_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pids_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResourceOffersMessage* default_instance_;
};
// -------------------------------------------------------------------

class LaunchTasksMessage : public ::google::protobuf::Message {
 public:
  LaunchTasksMessage();
  virtual ~LaunchTasksMessage();
  
  LaunchTasksMessage(const LaunchTasksMessage& from);
  
  inline LaunchTasksMessage& operator=(const LaunchTasksMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaunchTasksMessage& default_instance();
  
  void Swap(LaunchTasksMessage* other);
  
  // implements Message ----------------------------------------------
  
  LaunchTasksMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaunchTasksMessage& from);
  void MergeFrom(const LaunchTasksMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.OfferID offer_id = 2;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 2;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  
  // repeated .mesos.TaskDescription tasks = 3;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 3;
  inline const ::mesos::TaskDescription& tasks(int index) const;
  inline ::mesos::TaskDescription* mutable_tasks(int index);
  inline ::mesos::TaskDescription* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskDescription >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskDescription >*
      mutable_tasks();
  
  // required .mesos.Filters filters = 5;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 5;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.LaunchTasksMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::mesos::OfferID* offer_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskDescription > tasks_;
  ::mesos::Filters* filters_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LaunchTasksMessage* default_instance_;
};
// -------------------------------------------------------------------

class RescindResourceOfferMessage : public ::google::protobuf::Message {
 public:
  RescindResourceOfferMessage();
  virtual ~RescindResourceOfferMessage();
  
  RescindResourceOfferMessage(const RescindResourceOfferMessage& from);
  
  inline RescindResourceOfferMessage& operator=(const RescindResourceOfferMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RescindResourceOfferMessage& default_instance();
  
  void Swap(RescindResourceOfferMessage* other);
  
  // implements Message ----------------------------------------------
  
  RescindResourceOfferMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RescindResourceOfferMessage& from);
  void MergeFrom(const RescindResourceOfferMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.OfferID offer_id = 1;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 1;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.RescindResourceOfferMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::OfferID* offer_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RescindResourceOfferMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReviveOffersMessage : public ::google::protobuf::Message {
 public:
  ReviveOffersMessage();
  virtual ~ReviveOffersMessage();
  
  ReviveOffersMessage(const ReviveOffersMessage& from);
  
  inline ReviveOffersMessage& operator=(const ReviveOffersMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReviveOffersMessage& default_instance();
  
  void Swap(ReviveOffersMessage* other);
  
  // implements Message ----------------------------------------------
  
  ReviveOffersMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReviveOffersMessage& from);
  void MergeFrom(const ReviveOffersMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ReviveOffersMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ReviveOffersMessage* default_instance_;
};
// -------------------------------------------------------------------

class RunTaskMessage : public ::google::protobuf::Message {
 public:
  RunTaskMessage();
  virtual ~RunTaskMessage();
  
  RunTaskMessage(const RunTaskMessage& from);
  
  inline RunTaskMessage& operator=(const RunTaskMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunTaskMessage& default_instance();
  
  void Swap(RunTaskMessage* other);
  
  // implements Message ----------------------------------------------
  
  RunTaskMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunTaskMessage& from);
  void MergeFrom(const RunTaskMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.FrameworkInfo framework = 2;
  inline bool has_framework() const;
  inline void clear_framework();
  static const int kFrameworkFieldNumber = 2;
  inline const ::mesos::FrameworkInfo& framework() const;
  inline ::mesos::FrameworkInfo* mutable_framework();
  
  // required string pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  
  // required .mesos.TaskDescription task = 4;
  inline bool has_task() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 4;
  inline const ::mesos::TaskDescription& task() const;
  inline ::mesos::TaskDescription* mutable_task();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.RunTaskMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::mesos::FrameworkInfo* framework_;
  ::std::string* pid_;
  static const ::std::string _default_pid_;
  ::mesos::TaskDescription* task_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RunTaskMessage* default_instance_;
};
// -------------------------------------------------------------------

class KillTaskMessage : public ::google::protobuf::Message {
 public:
  KillTaskMessage();
  virtual ~KillTaskMessage();
  
  KillTaskMessage(const KillTaskMessage& from);
  
  inline KillTaskMessage& operator=(const KillTaskMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KillTaskMessage& default_instance();
  
  void Swap(KillTaskMessage* other);
  
  // implements Message ----------------------------------------------
  
  KillTaskMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KillTaskMessage& from);
  void MergeFrom(const KillTaskMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.KillTaskMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::mesos::TaskID* task_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KillTaskMessage* default_instance_;
};
// -------------------------------------------------------------------

class StatusUpdateMessage : public ::google::protobuf::Message {
 public:
  StatusUpdateMessage();
  virtual ~StatusUpdateMessage();
  
  StatusUpdateMessage(const StatusUpdateMessage& from);
  
  inline StatusUpdateMessage& operator=(const StatusUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdateMessage& default_instance();
  
  void Swap(StatusUpdateMessage* other);
  
  // implements Message ----------------------------------------------
  
  StatusUpdateMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusUpdateMessage& from);
  void MergeFrom(const StatusUpdateMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.internal.StatusUpdate update = 1;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 1;
  inline const ::mesos::internal::StatusUpdate& update() const;
  inline ::mesos::internal::StatusUpdate* mutable_update();
  
  // optional string pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.StatusUpdateMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::internal::StatusUpdate* update_;
  ::std::string* pid_;
  static const ::std::string _default_pid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StatusUpdateMessage* default_instance_;
};
// -------------------------------------------------------------------

class StatusUpdateAcknowledgementMessage : public ::google::protobuf::Message {
 public:
  StatusUpdateAcknowledgementMessage();
  virtual ~StatusUpdateAcknowledgementMessage();
  
  StatusUpdateAcknowledgementMessage(const StatusUpdateAcknowledgementMessage& from);
  
  inline StatusUpdateAcknowledgementMessage& operator=(const StatusUpdateAcknowledgementMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdateAcknowledgementMessage& default_instance();
  
  void Swap(StatusUpdateAcknowledgementMessage* other);
  
  // implements Message ----------------------------------------------
  
  StatusUpdateAcknowledgementMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusUpdateAcknowledgementMessage& from);
  void MergeFrom(const StatusUpdateAcknowledgementMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.TaskID task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  
  // required bytes uuid = 4;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 4;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.StatusUpdateAcknowledgementMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::TaskID* task_id_;
  ::std::string* uuid_;
  static const ::std::string _default_uuid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StatusUpdateAcknowledgementMessage* default_instance_;
};
// -------------------------------------------------------------------

class LostSlaveMessage : public ::google::protobuf::Message {
 public:
  LostSlaveMessage();
  virtual ~LostSlaveMessage();
  
  LostSlaveMessage(const LostSlaveMessage& from);
  
  inline LostSlaveMessage& operator=(const LostSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LostSlaveMessage& default_instance();
  
  void Swap(LostSlaveMessage* other);
  
  // implements Message ----------------------------------------------
  
  LostSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LostSlaveMessage& from);
  void MergeFrom(const LostSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.LostSlaveMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LostSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkErrorMessage : public ::google::protobuf::Message {
 public:
  FrameworkErrorMessage();
  virtual ~FrameworkErrorMessage();
  
  FrameworkErrorMessage(const FrameworkErrorMessage& from);
  
  inline FrameworkErrorMessage& operator=(const FrameworkErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkErrorMessage& default_instance();
  
  void Swap(FrameworkErrorMessage* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkErrorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkErrorMessage& from);
  void MergeFrom(const FrameworkErrorMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkErrorMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 code_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FrameworkErrorMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterSlaveMessage : public ::google::protobuf::Message {
 public:
  RegisterSlaveMessage();
  virtual ~RegisterSlaveMessage();
  
  RegisterSlaveMessage(const RegisterSlaveMessage& from);
  
  inline RegisterSlaveMessage& operator=(const RegisterSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterSlaveMessage& default_instance();
  
  void Swap(RegisterSlaveMessage* other);
  
  // implements Message ----------------------------------------------
  
  RegisterSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterSlaveMessage& from);
  void MergeFrom(const RegisterSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveInfo slave = 1;
  inline bool has_slave() const;
  inline void clear_slave();
  static const int kSlaveFieldNumber = 1;
  inline const ::mesos::SlaveInfo& slave() const;
  inline ::mesos::SlaveInfo* mutable_slave();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.RegisterSlaveMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveInfo* slave_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RegisterSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReregisterSlaveMessage : public ::google::protobuf::Message {
 public:
  ReregisterSlaveMessage();
  virtual ~ReregisterSlaveMessage();
  
  ReregisterSlaveMessage(const ReregisterSlaveMessage& from);
  
  inline ReregisterSlaveMessage& operator=(const ReregisterSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReregisterSlaveMessage& default_instance();
  
  void Swap(ReregisterSlaveMessage* other);
  
  // implements Message ----------------------------------------------
  
  ReregisterSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReregisterSlaveMessage& from);
  void MergeFrom(const ReregisterSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required .mesos.SlaveInfo slave = 2;
  inline bool has_slave() const;
  inline void clear_slave();
  static const int kSlaveFieldNumber = 2;
  inline const ::mesos::SlaveInfo& slave() const;
  inline ::mesos::SlaveInfo* mutable_slave();
  
  // repeated .mesos.ExecutorInfo executor_infos = 4;
  inline int executor_infos_size() const;
  inline void clear_executor_infos();
  static const int kExecutorInfosFieldNumber = 4;
  inline const ::mesos::ExecutorInfo& executor_infos(int index) const;
  inline ::mesos::ExecutorInfo* mutable_executor_infos(int index);
  inline ::mesos::ExecutorInfo* add_executor_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >&
      executor_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >*
      mutable_executor_infos();
  
  // repeated .mesos.internal.Task tasks = 3;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 3;
  inline const ::mesos::internal::Task& tasks(int index) const;
  inline ::mesos::internal::Task* mutable_tasks(int index);
  inline ::mesos::internal::Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >*
      mutable_tasks();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ReregisterSlaveMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  ::mesos::SlaveInfo* slave_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo > executor_infos_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task > tasks_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ReregisterSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class SlaveRegisteredMessage : public ::google::protobuf::Message {
 public:
  SlaveRegisteredMessage();
  virtual ~SlaveRegisteredMessage();
  
  SlaveRegisteredMessage(const SlaveRegisteredMessage& from);
  
  inline SlaveRegisteredMessage& operator=(const SlaveRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveRegisteredMessage& default_instance();
  
  void Swap(SlaveRegisteredMessage* other);
  
  // implements Message ----------------------------------------------
  
  SlaveRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveRegisteredMessage& from);
  void MergeFrom(const SlaveRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.SlaveRegisteredMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SlaveRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class SlaveReregisteredMessage : public ::google::protobuf::Message {
 public:
  SlaveReregisteredMessage();
  virtual ~SlaveReregisteredMessage();
  
  SlaveReregisteredMessage(const SlaveReregisteredMessage& from);
  
  inline SlaveReregisteredMessage& operator=(const SlaveReregisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveReregisteredMessage& default_instance();
  
  void Swap(SlaveReregisteredMessage* other);
  
  // implements Message ----------------------------------------------
  
  SlaveReregisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveReregisteredMessage& from);
  void MergeFrom(const SlaveReregisteredMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.SlaveReregisteredMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SlaveReregisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterSlaveMessage : public ::google::protobuf::Message {
 public:
  UnregisterSlaveMessage();
  virtual ~UnregisterSlaveMessage();
  
  UnregisterSlaveMessage(const UnregisterSlaveMessage& from);
  
  inline UnregisterSlaveMessage& operator=(const UnregisterSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterSlaveMessage& default_instance();
  
  void Swap(UnregisterSlaveMessage* other);
  
  // implements Message ----------------------------------------------
  
  UnregisterSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnregisterSlaveMessage& from);
  void MergeFrom(const UnregisterSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.UnregisterSlaveMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UnregisterSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatMessage : public ::google::protobuf::Message {
 public:
  HeartbeatMessage();
  virtual ~HeartbeatMessage();
  
  HeartbeatMessage(const HeartbeatMessage& from);
  
  inline HeartbeatMessage& operator=(const HeartbeatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatMessage& default_instance();
  
  void Swap(HeartbeatMessage* other);
  
  // implements Message ----------------------------------------------
  
  HeartbeatMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatMessage& from);
  void MergeFrom(const HeartbeatMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.HeartbeatMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HeartbeatMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownFrameworkMessage : public ::google::protobuf::Message {
 public:
  ShutdownFrameworkMessage();
  virtual ~ShutdownFrameworkMessage();
  
  ShutdownFrameworkMessage(const ShutdownFrameworkMessage& from);
  
  inline ShutdownFrameworkMessage& operator=(const ShutdownFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownFrameworkMessage& default_instance();
  
  void Swap(ShutdownFrameworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  ShutdownFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownFrameworkMessage& from);
  void MergeFrom(const ShutdownFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ShutdownFrameworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShutdownFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownExecutorMessage : public ::google::protobuf::Message {
 public:
  ShutdownExecutorMessage();
  virtual ~ShutdownExecutorMessage();
  
  ShutdownExecutorMessage(const ShutdownExecutorMessage& from);
  
  inline ShutdownExecutorMessage& operator=(const ShutdownExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownExecutorMessage& default_instance();
  
  void Swap(ShutdownExecutorMessage* other);
  
  // implements Message ----------------------------------------------
  
  ShutdownExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownExecutorMessage& from);
  void MergeFrom(const ShutdownExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ShutdownExecutorMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShutdownExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class UpdateFrameworkMessage : public ::google::protobuf::Message {
 public:
  UpdateFrameworkMessage();
  virtual ~UpdateFrameworkMessage();
  
  UpdateFrameworkMessage(const UpdateFrameworkMessage& from);
  
  inline UpdateFrameworkMessage& operator=(const UpdateFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateFrameworkMessage& default_instance();
  
  void Swap(UpdateFrameworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  UpdateFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateFrameworkMessage& from);
  void MergeFrom(const UpdateFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required string pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.UpdateFrameworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::std::string* pid_;
  static const ::std::string _default_pid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UpdateFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterExecutorMessage : public ::google::protobuf::Message {
 public:
  RegisterExecutorMessage();
  virtual ~RegisterExecutorMessage();
  
  RegisterExecutorMessage(const RegisterExecutorMessage& from);
  
  inline RegisterExecutorMessage& operator=(const RegisterExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterExecutorMessage& default_instance();
  
  void Swap(RegisterExecutorMessage* other);
  
  // implements Message ----------------------------------------------
  
  RegisterExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterExecutorMessage& from);
  void MergeFrom(const RegisterExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.RegisterExecutorMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RegisterExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorRegisteredMessage : public ::google::protobuf::Message {
 public:
  ExecutorRegisteredMessage();
  virtual ~ExecutorRegisteredMessage();
  
  ExecutorRegisteredMessage(const ExecutorRegisteredMessage& from);
  
  inline ExecutorRegisteredMessage& operator=(const ExecutorRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorRegisteredMessage& default_instance();
  
  void Swap(ExecutorRegisteredMessage* other);
  
  // implements Message ----------------------------------------------
  
  ExecutorRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorRegisteredMessage& from);
  void MergeFrom(const ExecutorRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.ExecutorArgs args = 1;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 1;
  inline const ::mesos::ExecutorArgs& args() const;
  inline ::mesos::ExecutorArgs* mutable_args();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ExecutorRegisteredMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::ExecutorArgs* args_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecutorRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class ExitedExecutorMessage : public ::google::protobuf::Message {
 public:
  ExitedExecutorMessage();
  virtual ~ExitedExecutorMessage();
  
  ExitedExecutorMessage(const ExitedExecutorMessage& from);
  
  inline ExitedExecutorMessage& operator=(const ExitedExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitedExecutorMessage& default_instance();
  
  void Swap(ExitedExecutorMessage* other);
  
  // implements Message ----------------------------------------------
  
  ExitedExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitedExecutorMessage& from);
  void MergeFrom(const ExitedExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  
  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // required .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  
  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ExitedExecutorMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExitedExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterProjdMessage : public ::google::protobuf::Message {
 public:
  RegisterProjdMessage();
  virtual ~RegisterProjdMessage();
  
  RegisterProjdMessage(const RegisterProjdMessage& from);
  
  inline RegisterProjdMessage& operator=(const RegisterProjdMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterProjdMessage& default_instance();
  
  void Swap(RegisterProjdMessage* other);
  
  // implements Message ----------------------------------------------
  
  RegisterProjdMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterProjdMessage& from);
  void MergeFrom(const RegisterProjdMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string project = 1;
  inline bool has_project() const;
  inline void clear_project();
  static const int kProjectFieldNumber = 1;
  inline const ::std::string& project() const;
  inline void set_project(const ::std::string& value);
  inline void set_project(const char* value);
  inline void set_project(const char* value, size_t size);
  inline ::std::string* mutable_project();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.RegisterProjdMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* project_;
  static const ::std::string _default_project_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RegisterProjdMessage* default_instance_;
};
// -------------------------------------------------------------------

class ProjdReadyMessage : public ::google::protobuf::Message {
 public:
  ProjdReadyMessage();
  virtual ~ProjdReadyMessage();
  
  ProjdReadyMessage(const ProjdReadyMessage& from);
  
  inline ProjdReadyMessage& operator=(const ProjdReadyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjdReadyMessage& default_instance();
  
  void Swap(ProjdReadyMessage* other);
  
  // implements Message ----------------------------------------------
  
  ProjdReadyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjdReadyMessage& from);
  void MergeFrom(const ProjdReadyMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string project = 1;
  inline bool has_project() const;
  inline void clear_project();
  static const int kProjectFieldNumber = 1;
  inline const ::std::string& project() const;
  inline void set_project(const ::std::string& value);
  inline void set_project(const char* value);
  inline void set_project(const char* value, size_t size);
  inline ::std::string* mutable_project();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ProjdReadyMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* project_;
  static const ::std::string _default_project_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProjdReadyMessage* default_instance_;
};
// -------------------------------------------------------------------

class ProjdUpdateResourcesMessage : public ::google::protobuf::Message {
 public:
  ProjdUpdateResourcesMessage();
  virtual ~ProjdUpdateResourcesMessage();
  
  ProjdUpdateResourcesMessage(const ProjdUpdateResourcesMessage& from);
  
  inline ProjdUpdateResourcesMessage& operator=(const ProjdUpdateResourcesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjdUpdateResourcesMessage& default_instance();
  
  void Swap(ProjdUpdateResourcesMessage* other);
  
  // implements Message ----------------------------------------------
  
  ProjdUpdateResourcesMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjdUpdateResourcesMessage& from);
  void MergeFrom(const ProjdUpdateResourcesMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mesos.Params params = 1;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 1;
  inline const ::mesos::Params& params() const;
  inline ::mesos::Params* mutable_params();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ProjdUpdateResourcesMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::Params* params_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProjdUpdateResourcesMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkExpiredMessage : public ::google::protobuf::Message {
 public:
  FrameworkExpiredMessage();
  virtual ~FrameworkExpiredMessage();
  
  FrameworkExpiredMessage(const FrameworkExpiredMessage& from);
  
  inline FrameworkExpiredMessage& operator=(const FrameworkExpiredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkExpiredMessage& default_instance();
  
  void Swap(FrameworkExpiredMessage* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkExpiredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkExpiredMessage& from);
  void MergeFrom(const FrameworkExpiredMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkExpiredMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::mesos::FrameworkID* framework_id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FrameworkExpiredMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownMessage : public ::google::protobuf::Message {
 public:
  ShutdownMessage();
  virtual ~ShutdownMessage();
  
  ShutdownMessage(const ShutdownMessage& from);
  
  inline ShutdownMessage& operator=(const ShutdownMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownMessage& default_instance();
  
  void Swap(ShutdownMessage* other);
  
  // implements Message ----------------------------------------------
  
  ShutdownMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownMessage& from);
  void MergeFrom(const ShutdownMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:mesos.internal.ShutdownMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShutdownMessage* default_instance_;
};
// -------------------------------------------------------------------

class NoMasterDetectedMessage : public ::google::protobuf::Message {
 public:
  NoMasterDetectedMessage();
  virtual ~NoMasterDetectedMessage();
  
  NoMasterDetectedMessage(const NoMasterDetectedMessage& from);
  
  inline NoMasterDetectedMessage& operator=(const NoMasterDetectedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NoMasterDetectedMessage& default_instance();
  
  void Swap(NoMasterDetectedMessage* other);
  
  // implements Message ----------------------------------------------
  
  NoMasterDetectedMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoMasterDetectedMessage& from);
  void MergeFrom(const NoMasterDetectedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:mesos.internal.NoMasterDetectedMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NoMasterDetectedMessage* default_instance_;
};
// -------------------------------------------------------------------

class NewMasterDetectedMessage : public ::google::protobuf::Message {
 public:
  NewMasterDetectedMessage();
  virtual ~NewMasterDetectedMessage();
  
  NewMasterDetectedMessage(const NewMasterDetectedMessage& from);
  
  inline NewMasterDetectedMessage& operator=(const NewMasterDetectedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewMasterDetectedMessage& default_instance();
  
  void Swap(NewMasterDetectedMessage* other);
  
  // implements Message ----------------------------------------------
  
  NewMasterDetectedMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewMasterDetectedMessage& from);
  void MergeFrom(const NewMasterDetectedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.NewMasterDetectedMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* pid_;
  static const ::std::string _default_pid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NewMasterDetectedMessage* default_instance_;
};
// -------------------------------------------------------------------

class GotMasterTokenMessage : public ::google::protobuf::Message {
 public:
  GotMasterTokenMessage();
  virtual ~GotMasterTokenMessage();
  
  GotMasterTokenMessage(const GotMasterTokenMessage& from);
  
  inline GotMasterTokenMessage& operator=(const GotMasterTokenMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GotMasterTokenMessage& default_instance();
  
  void Swap(GotMasterTokenMessage* other);
  
  // implements Message ----------------------------------------------
  
  GotMasterTokenMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GotMasterTokenMessage& from);
  void MergeFrom(const GotMasterTokenMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  
  // @@protoc_insertion_point(class_scope:mesos.internal.GotMasterTokenMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* token_;
  static const ::std::string _default_token_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GotMasterTokenMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Task

// required string name = 1;
inline bool Task::has_name() const {
  return _has_bit(0);
}
inline void Task::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Task::name() const {
  return *name_;
}
inline void Task::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .mesos.TaskID task_id = 2;
inline bool Task::has_task_id() const {
  return _has_bit(1);
}
inline void Task::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  _clear_bit(1);
}
inline const ::mesos::TaskID& Task::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Task::mutable_task_id() {
  _set_bit(1);
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}

// required .mesos.FrameworkID framework_id = 3;
inline bool Task::has_framework_id() const {
  return _has_bit(2);
}
inline void Task::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(2);
}
inline const ::mesos::FrameworkID& Task::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Task::mutable_framework_id() {
  _set_bit(2);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.ExecutorID executor_id = 4;
inline bool Task::has_executor_id() const {
  return _has_bit(3);
}
inline void Task::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(3);
}
inline const ::mesos::ExecutorID& Task::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Task::mutable_executor_id() {
  _set_bit(3);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// required .mesos.SlaveID slave_id = 5;
inline bool Task::has_slave_id() const {
  return _has_bit(4);
}
inline void Task::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(4);
}
inline const ::mesos::SlaveID& Task::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Task::mutable_slave_id() {
  _set_bit(4);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required .mesos.TaskState state = 6;
inline bool Task::has_state() const {
  return _has_bit(5);
}
inline void Task::clear_state() {
  state_ = 0;
  _clear_bit(5);
}
inline mesos::TaskState Task::state() const {
  return static_cast< mesos::TaskState >(state_);
}
inline void Task::set_state(mesos::TaskState value) {
  GOOGLE_DCHECK(mesos::TaskState_IsValid(value));
  _set_bit(5);
  state_ = value;
}

// repeated .mesos.Resource resources = 7;
inline int Task::resources_size() const {
  return resources_.size();
}
inline void Task::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Task::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Task::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Task::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Task::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Task::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// StatusUpdate

// required .mesos.FrameworkID framework_id = 1;
inline bool StatusUpdate::has_framework_id() const {
  return _has_bit(0);
}
inline void StatusUpdate::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& StatusUpdate::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* StatusUpdate::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// optional .mesos.ExecutorID executor_id = 2;
inline bool StatusUpdate::has_executor_id() const {
  return _has_bit(1);
}
inline void StatusUpdate::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(1);
}
inline const ::mesos::ExecutorID& StatusUpdate::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* StatusUpdate::mutable_executor_id() {
  _set_bit(1);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// optional .mesos.SlaveID slave_id = 3;
inline bool StatusUpdate::has_slave_id() const {
  return _has_bit(2);
}
inline void StatusUpdate::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(2);
}
inline const ::mesos::SlaveID& StatusUpdate::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* StatusUpdate::mutable_slave_id() {
  _set_bit(2);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required .mesos.TaskStatus status = 4;
inline bool StatusUpdate::has_status() const {
  return _has_bit(3);
}
inline void StatusUpdate::clear_status() {
  if (status_ != NULL) status_->::mesos::TaskStatus::Clear();
  _clear_bit(3);
}
inline const ::mesos::TaskStatus& StatusUpdate::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::mesos::TaskStatus* StatusUpdate::mutable_status() {
  _set_bit(3);
  if (status_ == NULL) status_ = new ::mesos::TaskStatus;
  return status_;
}

// required double timestamp = 5;
inline bool StatusUpdate::has_timestamp() const {
  return _has_bit(4);
}
inline void StatusUpdate::clear_timestamp() {
  timestamp_ = 0;
  _clear_bit(4);
}
inline double StatusUpdate::timestamp() const {
  return timestamp_;
}
inline void StatusUpdate::set_timestamp(double value) {
  _set_bit(4);
  timestamp_ = value;
}

// required bytes uuid = 6;
inline bool StatusUpdate::has_uuid() const {
  return _has_bit(5);
}
inline void StatusUpdate::clear_uuid() {
  if (uuid_ != &_default_uuid_) {
    uuid_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StatusUpdate::uuid() const {
  return *uuid_;
}
inline void StatusUpdate::set_uuid(const ::std::string& value) {
  _set_bit(5);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdate::set_uuid(const char* value) {
  _set_bit(5);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdate::set_uuid(const void* value, size_t size) {
  _set_bit(5);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusUpdate::mutable_uuid() {
  _set_bit(5);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}

// -------------------------------------------------------------------

// SubmitSchedulerRequest

// required string name = 1;
inline bool SubmitSchedulerRequest::has_name() const {
  return _has_bit(0);
}
inline void SubmitSchedulerRequest::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SubmitSchedulerRequest::name() const {
  return *name_;
}
inline void SubmitSchedulerRequest::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SubmitSchedulerRequest::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SubmitSchedulerRequest::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubmitSchedulerRequest::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// SubmitSchedulerResponse

// required bool okay = 1;
inline bool SubmitSchedulerResponse::has_okay() const {
  return _has_bit(0);
}
inline void SubmitSchedulerResponse::clear_okay() {
  okay_ = false;
  _clear_bit(0);
}
inline bool SubmitSchedulerResponse::okay() const {
  return okay_;
}
inline void SubmitSchedulerResponse::set_okay(bool value) {
  _set_bit(0);
  okay_ = value;
}

// -------------------------------------------------------------------

// ExecutorToFrameworkMessage

// required .mesos.SlaveID slave_id = 1;
inline bool ExecutorToFrameworkMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void ExecutorToFrameworkMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& ExecutorToFrameworkMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ExecutorToFrameworkMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ExecutorToFrameworkMessage::has_framework_id() const {
  return _has_bit(1);
}
inline void ExecutorToFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(1);
}
inline const ::mesos::FrameworkID& ExecutorToFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorToFrameworkMessage::mutable_framework_id() {
  _set_bit(1);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.ExecutorID executor_id = 3;
inline bool ExecutorToFrameworkMessage::has_executor_id() const {
  return _has_bit(2);
}
inline void ExecutorToFrameworkMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(2);
}
inline const ::mesos::ExecutorID& ExecutorToFrameworkMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorToFrameworkMessage::mutable_executor_id() {
  _set_bit(2);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// required bytes data = 4;
inline bool ExecutorToFrameworkMessage::has_data() const {
  return _has_bit(3);
}
inline void ExecutorToFrameworkMessage::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& ExecutorToFrameworkMessage::data() const {
  return *data_;
}
inline void ExecutorToFrameworkMessage::set_data(const ::std::string& value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorToFrameworkMessage::set_data(const char* value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorToFrameworkMessage::set_data(const void* value, size_t size) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorToFrameworkMessage::mutable_data() {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// FrameworkToExecutorMessage

// required .mesos.SlaveID slave_id = 1;
inline bool FrameworkToExecutorMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void FrameworkToExecutorMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& FrameworkToExecutorMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* FrameworkToExecutorMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required .mesos.FrameworkID framework_id = 2;
inline bool FrameworkToExecutorMessage::has_framework_id() const {
  return _has_bit(1);
}
inline void FrameworkToExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(1);
}
inline const ::mesos::FrameworkID& FrameworkToExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* FrameworkToExecutorMessage::mutable_framework_id() {
  _set_bit(1);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.ExecutorID executor_id = 3;
inline bool FrameworkToExecutorMessage::has_executor_id() const {
  return _has_bit(2);
}
inline void FrameworkToExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(2);
}
inline const ::mesos::ExecutorID& FrameworkToExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* FrameworkToExecutorMessage::mutable_executor_id() {
  _set_bit(2);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// required bytes data = 4;
inline bool FrameworkToExecutorMessage::has_data() const {
  return _has_bit(3);
}
inline void FrameworkToExecutorMessage::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& FrameworkToExecutorMessage::data() const {
  return *data_;
}
inline void FrameworkToExecutorMessage::set_data(const ::std::string& value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FrameworkToExecutorMessage::set_data(const char* value) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FrameworkToExecutorMessage::set_data(const void* value, size_t size) {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkToExecutorMessage::mutable_data() {
  _set_bit(3);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// RegisterFrameworkMessage

// required .mesos.FrameworkInfo framework = 1;
inline bool RegisterFrameworkMessage::has_framework() const {
  return _has_bit(0);
}
inline void RegisterFrameworkMessage::clear_framework() {
  if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkInfo& RegisterFrameworkMessage::framework() const {
  return framework_ != NULL ? *framework_ : *default_instance_->framework_;
}
inline ::mesos::FrameworkInfo* RegisterFrameworkMessage::mutable_framework() {
  _set_bit(0);
  if (framework_ == NULL) framework_ = new ::mesos::FrameworkInfo;
  return framework_;
}

// -------------------------------------------------------------------

// ReregisterFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ReregisterFrameworkMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void ReregisterFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& ReregisterFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ReregisterFrameworkMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.FrameworkInfo framework = 2;
inline bool ReregisterFrameworkMessage::has_framework() const {
  return _has_bit(1);
}
inline void ReregisterFrameworkMessage::clear_framework() {
  if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
  _clear_bit(1);
}
inline const ::mesos::FrameworkInfo& ReregisterFrameworkMessage::framework() const {
  return framework_ != NULL ? *framework_ : *default_instance_->framework_;
}
inline ::mesos::FrameworkInfo* ReregisterFrameworkMessage::mutable_framework() {
  _set_bit(1);
  if (framework_ == NULL) framework_ = new ::mesos::FrameworkInfo;
  return framework_;
}

// required bool failover = 3;
inline bool ReregisterFrameworkMessage::has_failover() const {
  return _has_bit(2);
}
inline void ReregisterFrameworkMessage::clear_failover() {
  failover_ = false;
  _clear_bit(2);
}
inline bool ReregisterFrameworkMessage::failover() const {
  return failover_;
}
inline void ReregisterFrameworkMessage::set_failover(bool value) {
  _set_bit(2);
  failover_ = value;
}

// -------------------------------------------------------------------

// FrameworkRegisteredMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool FrameworkRegisteredMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void FrameworkRegisteredMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& FrameworkRegisteredMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* FrameworkRegisteredMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// -------------------------------------------------------------------

// FrameworkReregisteredMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool FrameworkReregisteredMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void FrameworkReregisteredMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& FrameworkReregisteredMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* FrameworkReregisteredMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// -------------------------------------------------------------------

// UnregisterFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool UnregisterFrameworkMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void UnregisterFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& UnregisterFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* UnregisterFrameworkMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// -------------------------------------------------------------------

// DeactivateFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool DeactivateFrameworkMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void DeactivateFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& DeactivateFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* DeactivateFrameworkMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// -------------------------------------------------------------------

// ResourceRequestMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ResourceRequestMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void ResourceRequestMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& ResourceRequestMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ResourceRequestMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// repeated .mesos.ResourceRequest requests = 2;
inline int ResourceRequestMessage::requests_size() const {
  return requests_.size();
}
inline void ResourceRequestMessage::clear_requests() {
  requests_.Clear();
}
inline const ::mesos::ResourceRequest& ResourceRequestMessage::requests(int index) const {
  return requests_.Get(index);
}
inline ::mesos::ResourceRequest* ResourceRequestMessage::mutable_requests(int index) {
  return requests_.Mutable(index);
}
inline ::mesos::ResourceRequest* ResourceRequestMessage::add_requests() {
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceRequest >&
ResourceRequestMessage::requests() const {
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceRequest >*
ResourceRequestMessage::mutable_requests() {
  return &requests_;
}

// -------------------------------------------------------------------

// ResourceOffersMessage

// repeated .mesos.Offer offers = 1;
inline int ResourceOffersMessage::offers_size() const {
  return offers_.size();
}
inline void ResourceOffersMessage::clear_offers() {
  offers_.Clear();
}
inline const ::mesos::Offer& ResourceOffersMessage::offers(int index) const {
  return offers_.Get(index);
}
inline ::mesos::Offer* ResourceOffersMessage::mutable_offers(int index) {
  return offers_.Mutable(index);
}
inline ::mesos::Offer* ResourceOffersMessage::add_offers() {
  return offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
ResourceOffersMessage::offers() const {
  return offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
ResourceOffersMessage::mutable_offers() {
  return &offers_;
}

// repeated string pids = 2;
inline int ResourceOffersMessage::pids_size() const {
  return pids_.size();
}
inline void ResourceOffersMessage::clear_pids() {
  pids_.Clear();
}
inline const ::std::string& ResourceOffersMessage::pids(int index) const {
  return pids_.Get(index);
}
inline ::std::string* ResourceOffersMessage::mutable_pids(int index) {
  return pids_.Mutable(index);
}
inline void ResourceOffersMessage::set_pids(int index, const ::std::string& value) {
  pids_.Mutable(index)->assign(value);
}
inline void ResourceOffersMessage::set_pids(int index, const char* value) {
  pids_.Mutable(index)->assign(value);
}
inline void ResourceOffersMessage::set_pids(int index, const char* value, size_t size) {
  pids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceOffersMessage::add_pids() {
  return pids_.Add();
}
inline void ResourceOffersMessage::add_pids(const ::std::string& value) {
  pids_.Add()->assign(value);
}
inline void ResourceOffersMessage::add_pids(const char* value) {
  pids_.Add()->assign(value);
}
inline void ResourceOffersMessage::add_pids(const char* value, size_t size) {
  pids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResourceOffersMessage::pids() const {
  return pids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResourceOffersMessage::mutable_pids() {
  return &pids_;
}

// -------------------------------------------------------------------

// LaunchTasksMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool LaunchTasksMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void LaunchTasksMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& LaunchTasksMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* LaunchTasksMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.OfferID offer_id = 2;
inline bool LaunchTasksMessage::has_offer_id() const {
  return _has_bit(1);
}
inline void LaunchTasksMessage::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  _clear_bit(1);
}
inline const ::mesos::OfferID& LaunchTasksMessage::offer_id() const {
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* LaunchTasksMessage::mutable_offer_id() {
  _set_bit(1);
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  return offer_id_;
}

// repeated .mesos.TaskDescription tasks = 3;
inline int LaunchTasksMessage::tasks_size() const {
  return tasks_.size();
}
inline void LaunchTasksMessage::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::TaskDescription& LaunchTasksMessage::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::mesos::TaskDescription* LaunchTasksMessage::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::mesos::TaskDescription* LaunchTasksMessage::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskDescription >&
LaunchTasksMessage::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskDescription >*
LaunchTasksMessage::mutable_tasks() {
  return &tasks_;
}

// required .mesos.Filters filters = 5;
inline bool LaunchTasksMessage::has_filters() const {
  return _has_bit(3);
}
inline void LaunchTasksMessage::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  _clear_bit(3);
}
inline const ::mesos::Filters& LaunchTasksMessage::filters() const {
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* LaunchTasksMessage::mutable_filters() {
  _set_bit(3);
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  return filters_;
}

// -------------------------------------------------------------------

// RescindResourceOfferMessage

// required .mesos.OfferID offer_id = 1;
inline bool RescindResourceOfferMessage::has_offer_id() const {
  return _has_bit(0);
}
inline void RescindResourceOfferMessage::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  _clear_bit(0);
}
inline const ::mesos::OfferID& RescindResourceOfferMessage::offer_id() const {
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* RescindResourceOfferMessage::mutable_offer_id() {
  _set_bit(0);
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  return offer_id_;
}

// -------------------------------------------------------------------

// ReviveOffersMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ReviveOffersMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void ReviveOffersMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& ReviveOffersMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ReviveOffersMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// -------------------------------------------------------------------

// RunTaskMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool RunTaskMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void RunTaskMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& RunTaskMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* RunTaskMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.FrameworkInfo framework = 2;
inline bool RunTaskMessage::has_framework() const {
  return _has_bit(1);
}
inline void RunTaskMessage::clear_framework() {
  if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
  _clear_bit(1);
}
inline const ::mesos::FrameworkInfo& RunTaskMessage::framework() const {
  return framework_ != NULL ? *framework_ : *default_instance_->framework_;
}
inline ::mesos::FrameworkInfo* RunTaskMessage::mutable_framework() {
  _set_bit(1);
  if (framework_ == NULL) framework_ = new ::mesos::FrameworkInfo;
  return framework_;
}

// required string pid = 3;
inline bool RunTaskMessage::has_pid() const {
  return _has_bit(2);
}
inline void RunTaskMessage::clear_pid() {
  if (pid_ != &_default_pid_) {
    pid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RunTaskMessage::pid() const {
  return *pid_;
}
inline void RunTaskMessage::set_pid(const ::std::string& value) {
  _set_bit(2);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void RunTaskMessage::set_pid(const char* value) {
  _set_bit(2);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void RunTaskMessage::set_pid(const char* value, size_t size) {
  _set_bit(2);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunTaskMessage::mutable_pid() {
  _set_bit(2);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  return pid_;
}

// required .mesos.TaskDescription task = 4;
inline bool RunTaskMessage::has_task() const {
  return _has_bit(3);
}
inline void RunTaskMessage::clear_task() {
  if (task_ != NULL) task_->::mesos::TaskDescription::Clear();
  _clear_bit(3);
}
inline const ::mesos::TaskDescription& RunTaskMessage::task() const {
  return task_ != NULL ? *task_ : *default_instance_->task_;
}
inline ::mesos::TaskDescription* RunTaskMessage::mutable_task() {
  _set_bit(3);
  if (task_ == NULL) task_ = new ::mesos::TaskDescription;
  return task_;
}

// -------------------------------------------------------------------

// KillTaskMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool KillTaskMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void KillTaskMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& KillTaskMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* KillTaskMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.TaskID task_id = 2;
inline bool KillTaskMessage::has_task_id() const {
  return _has_bit(1);
}
inline void KillTaskMessage::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  _clear_bit(1);
}
inline const ::mesos::TaskID& KillTaskMessage::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* KillTaskMessage::mutable_task_id() {
  _set_bit(1);
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}

// -------------------------------------------------------------------

// StatusUpdateMessage

// required .mesos.internal.StatusUpdate update = 1;
inline bool StatusUpdateMessage::has_update() const {
  return _has_bit(0);
}
inline void StatusUpdateMessage::clear_update() {
  if (update_ != NULL) update_->::mesos::internal::StatusUpdate::Clear();
  _clear_bit(0);
}
inline const ::mesos::internal::StatusUpdate& StatusUpdateMessage::update() const {
  return update_ != NULL ? *update_ : *default_instance_->update_;
}
inline ::mesos::internal::StatusUpdate* StatusUpdateMessage::mutable_update() {
  _set_bit(0);
  if (update_ == NULL) update_ = new ::mesos::internal::StatusUpdate;
  return update_;
}

// optional string pid = 2;
inline bool StatusUpdateMessage::has_pid() const {
  return _has_bit(1);
}
inline void StatusUpdateMessage::clear_pid() {
  if (pid_ != &_default_pid_) {
    pid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StatusUpdateMessage::pid() const {
  return *pid_;
}
inline void StatusUpdateMessage::set_pid(const ::std::string& value) {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void StatusUpdateMessage::set_pid(const char* value) {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void StatusUpdateMessage::set_pid(const char* value, size_t size) {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusUpdateMessage::mutable_pid() {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  return pid_;
}

// -------------------------------------------------------------------

// StatusUpdateAcknowledgementMessage

// required .mesos.SlaveID slave_id = 1;
inline bool StatusUpdateAcknowledgementMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void StatusUpdateAcknowledgementMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& StatusUpdateAcknowledgementMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* StatusUpdateAcknowledgementMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required .mesos.FrameworkID framework_id = 2;
inline bool StatusUpdateAcknowledgementMessage::has_framework_id() const {
  return _has_bit(1);
}
inline void StatusUpdateAcknowledgementMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(1);
}
inline const ::mesos::FrameworkID& StatusUpdateAcknowledgementMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* StatusUpdateAcknowledgementMessage::mutable_framework_id() {
  _set_bit(1);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.TaskID task_id = 3;
inline bool StatusUpdateAcknowledgementMessage::has_task_id() const {
  return _has_bit(2);
}
inline void StatusUpdateAcknowledgementMessage::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  _clear_bit(2);
}
inline const ::mesos::TaskID& StatusUpdateAcknowledgementMessage::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* StatusUpdateAcknowledgementMessage::mutable_task_id() {
  _set_bit(2);
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}

// required bytes uuid = 4;
inline bool StatusUpdateAcknowledgementMessage::has_uuid() const {
  return _has_bit(3);
}
inline void StatusUpdateAcknowledgementMessage::clear_uuid() {
  if (uuid_ != &_default_uuid_) {
    uuid_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StatusUpdateAcknowledgementMessage::uuid() const {
  return *uuid_;
}
inline void StatusUpdateAcknowledgementMessage::set_uuid(const ::std::string& value) {
  _set_bit(3);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdateAcknowledgementMessage::set_uuid(const char* value) {
  _set_bit(3);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdateAcknowledgementMessage::set_uuid(const void* value, size_t size) {
  _set_bit(3);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusUpdateAcknowledgementMessage::mutable_uuid() {
  _set_bit(3);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}

// -------------------------------------------------------------------

// LostSlaveMessage

// required .mesos.SlaveID slave_id = 1;
inline bool LostSlaveMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void LostSlaveMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& LostSlaveMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* LostSlaveMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// -------------------------------------------------------------------

// FrameworkErrorMessage

// required int32 code = 1;
inline bool FrameworkErrorMessage::has_code() const {
  return _has_bit(0);
}
inline void FrameworkErrorMessage::clear_code() {
  code_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FrameworkErrorMessage::code() const {
  return code_;
}
inline void FrameworkErrorMessage::set_code(::google::protobuf::int32 value) {
  _set_bit(0);
  code_ = value;
}

// required string message = 2;
inline bool FrameworkErrorMessage::has_message() const {
  return _has_bit(1);
}
inline void FrameworkErrorMessage::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& FrameworkErrorMessage::message() const {
  return *message_;
}
inline void FrameworkErrorMessage::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void FrameworkErrorMessage::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void FrameworkErrorMessage::set_message(const char* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkErrorMessage::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// RegisterSlaveMessage

// required .mesos.SlaveInfo slave = 1;
inline bool RegisterSlaveMessage::has_slave() const {
  return _has_bit(0);
}
inline void RegisterSlaveMessage::clear_slave() {
  if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveInfo& RegisterSlaveMessage::slave() const {
  return slave_ != NULL ? *slave_ : *default_instance_->slave_;
}
inline ::mesos::SlaveInfo* RegisterSlaveMessage::mutable_slave() {
  _set_bit(0);
  if (slave_ == NULL) slave_ = new ::mesos::SlaveInfo;
  return slave_;
}

// -------------------------------------------------------------------

// ReregisterSlaveMessage

// required .mesos.SlaveID slave_id = 1;
inline bool ReregisterSlaveMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void ReregisterSlaveMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& ReregisterSlaveMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ReregisterSlaveMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required .mesos.SlaveInfo slave = 2;
inline bool ReregisterSlaveMessage::has_slave() const {
  return _has_bit(1);
}
inline void ReregisterSlaveMessage::clear_slave() {
  if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
  _clear_bit(1);
}
inline const ::mesos::SlaveInfo& ReregisterSlaveMessage::slave() const {
  return slave_ != NULL ? *slave_ : *default_instance_->slave_;
}
inline ::mesos::SlaveInfo* ReregisterSlaveMessage::mutable_slave() {
  _set_bit(1);
  if (slave_ == NULL) slave_ = new ::mesos::SlaveInfo;
  return slave_;
}

// repeated .mesos.ExecutorInfo executor_infos = 4;
inline int ReregisterSlaveMessage::executor_infos_size() const {
  return executor_infos_.size();
}
inline void ReregisterSlaveMessage::clear_executor_infos() {
  executor_infos_.Clear();
}
inline const ::mesos::ExecutorInfo& ReregisterSlaveMessage::executor_infos(int index) const {
  return executor_infos_.Get(index);
}
inline ::mesos::ExecutorInfo* ReregisterSlaveMessage::mutable_executor_infos(int index) {
  return executor_infos_.Mutable(index);
}
inline ::mesos::ExecutorInfo* ReregisterSlaveMessage::add_executor_infos() {
  return executor_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >&
ReregisterSlaveMessage::executor_infos() const {
  return executor_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >*
ReregisterSlaveMessage::mutable_executor_infos() {
  return &executor_infos_;
}

// repeated .mesos.internal.Task tasks = 3;
inline int ReregisterSlaveMessage::tasks_size() const {
  return tasks_.size();
}
inline void ReregisterSlaveMessage::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::internal::Task& ReregisterSlaveMessage::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::mesos::internal::Task* ReregisterSlaveMessage::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::mesos::internal::Task* ReregisterSlaveMessage::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >&
ReregisterSlaveMessage::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >*
ReregisterSlaveMessage::mutable_tasks() {
  return &tasks_;
}

// -------------------------------------------------------------------

// SlaveRegisteredMessage

// required .mesos.SlaveID slave_id = 1;
inline bool SlaveRegisteredMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void SlaveRegisteredMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& SlaveRegisteredMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* SlaveRegisteredMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// -------------------------------------------------------------------

// SlaveReregisteredMessage

// required .mesos.SlaveID slave_id = 1;
inline bool SlaveReregisteredMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void SlaveReregisteredMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& SlaveReregisteredMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* SlaveReregisteredMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// -------------------------------------------------------------------

// UnregisterSlaveMessage

// required .mesos.SlaveID slave_id = 1;
inline bool UnregisterSlaveMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void UnregisterSlaveMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& UnregisterSlaveMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* UnregisterSlaveMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// -------------------------------------------------------------------

// HeartbeatMessage

// required .mesos.SlaveID slave_id = 1;
inline bool HeartbeatMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void HeartbeatMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& HeartbeatMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* HeartbeatMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// -------------------------------------------------------------------

// ShutdownFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ShutdownFrameworkMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void ShutdownFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& ShutdownFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ShutdownFrameworkMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// -------------------------------------------------------------------

// ShutdownExecutorMessage

// -------------------------------------------------------------------

// UpdateFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool UpdateFrameworkMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void UpdateFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& UpdateFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* UpdateFrameworkMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required string pid = 2;
inline bool UpdateFrameworkMessage::has_pid() const {
  return _has_bit(1);
}
inline void UpdateFrameworkMessage::clear_pid() {
  if (pid_ != &_default_pid_) {
    pid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UpdateFrameworkMessage::pid() const {
  return *pid_;
}
inline void UpdateFrameworkMessage::set_pid(const ::std::string& value) {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void UpdateFrameworkMessage::set_pid(const char* value) {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void UpdateFrameworkMessage::set_pid(const char* value, size_t size) {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateFrameworkMessage::mutable_pid() {
  _set_bit(1);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  return pid_;
}

// -------------------------------------------------------------------

// RegisterExecutorMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool RegisterExecutorMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void RegisterExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& RegisterExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* RegisterExecutorMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.ExecutorID executor_id = 2;
inline bool RegisterExecutorMessage::has_executor_id() const {
  return _has_bit(1);
}
inline void RegisterExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(1);
}
inline const ::mesos::ExecutorID& RegisterExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* RegisterExecutorMessage::mutable_executor_id() {
  _set_bit(1);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// -------------------------------------------------------------------

// ExecutorRegisteredMessage

// required .mesos.ExecutorArgs args = 1;
inline bool ExecutorRegisteredMessage::has_args() const {
  return _has_bit(0);
}
inline void ExecutorRegisteredMessage::clear_args() {
  if (args_ != NULL) args_->::mesos::ExecutorArgs::Clear();
  _clear_bit(0);
}
inline const ::mesos::ExecutorArgs& ExecutorRegisteredMessage::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::mesos::ExecutorArgs* ExecutorRegisteredMessage::mutable_args() {
  _set_bit(0);
  if (args_ == NULL) args_ = new ::mesos::ExecutorArgs;
  return args_;
}

// -------------------------------------------------------------------

// ExitedExecutorMessage

// required .mesos.SlaveID slave_id = 1;
inline bool ExitedExecutorMessage::has_slave_id() const {
  return _has_bit(0);
}
inline void ExitedExecutorMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  _clear_bit(0);
}
inline const ::mesos::SlaveID& ExitedExecutorMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ExitedExecutorMessage::mutable_slave_id() {
  _set_bit(0);
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ExitedExecutorMessage::has_framework_id() const {
  return _has_bit(1);
}
inline void ExitedExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(1);
}
inline const ::mesos::FrameworkID& ExitedExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExitedExecutorMessage::mutable_framework_id() {
  _set_bit(1);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// required .mesos.ExecutorID executor_id = 3;
inline bool ExitedExecutorMessage::has_executor_id() const {
  return _has_bit(2);
}
inline void ExitedExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  _clear_bit(2);
}
inline const ::mesos::ExecutorID& ExitedExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExitedExecutorMessage::mutable_executor_id() {
  _set_bit(2);
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}

// required int32 status = 4;
inline bool ExitedExecutorMessage::has_status() const {
  return _has_bit(3);
}
inline void ExitedExecutorMessage::clear_status() {
  status_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 ExitedExecutorMessage::status() const {
  return status_;
}
inline void ExitedExecutorMessage::set_status(::google::protobuf::int32 value) {
  _set_bit(3);
  status_ = value;
}

// -------------------------------------------------------------------

// RegisterProjdMessage

// required string project = 1;
inline bool RegisterProjdMessage::has_project() const {
  return _has_bit(0);
}
inline void RegisterProjdMessage::clear_project() {
  if (project_ != &_default_project_) {
    project_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RegisterProjdMessage::project() const {
  return *project_;
}
inline void RegisterProjdMessage::set_project(const ::std::string& value) {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  project_->assign(value);
}
inline void RegisterProjdMessage::set_project(const char* value) {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  project_->assign(value);
}
inline void RegisterProjdMessage::set_project(const char* value, size_t size) {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  project_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterProjdMessage::mutable_project() {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  return project_;
}

// -------------------------------------------------------------------

// ProjdReadyMessage

// required string project = 1;
inline bool ProjdReadyMessage::has_project() const {
  return _has_bit(0);
}
inline void ProjdReadyMessage::clear_project() {
  if (project_ != &_default_project_) {
    project_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ProjdReadyMessage::project() const {
  return *project_;
}
inline void ProjdReadyMessage::set_project(const ::std::string& value) {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  project_->assign(value);
}
inline void ProjdReadyMessage::set_project(const char* value) {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  project_->assign(value);
}
inline void ProjdReadyMessage::set_project(const char* value, size_t size) {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  project_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjdReadyMessage::mutable_project() {
  _set_bit(0);
  if (project_ == &_default_project_) {
    project_ = new ::std::string;
  }
  return project_;
}

// -------------------------------------------------------------------

// ProjdUpdateResourcesMessage

// optional .mesos.Params params = 1;
inline bool ProjdUpdateResourcesMessage::has_params() const {
  return _has_bit(0);
}
inline void ProjdUpdateResourcesMessage::clear_params() {
  if (params_ != NULL) params_->::mesos::Params::Clear();
  _clear_bit(0);
}
inline const ::mesos::Params& ProjdUpdateResourcesMessage::params() const {
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::mesos::Params* ProjdUpdateResourcesMessage::mutable_params() {
  _set_bit(0);
  if (params_ == NULL) params_ = new ::mesos::Params;
  return params_;
}

// -------------------------------------------------------------------

// FrameworkExpiredMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool FrameworkExpiredMessage::has_framework_id() const {
  return _has_bit(0);
}
inline void FrameworkExpiredMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  _clear_bit(0);
}
inline const ::mesos::FrameworkID& FrameworkExpiredMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* FrameworkExpiredMessage::mutable_framework_id() {
  _set_bit(0);
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}

// -------------------------------------------------------------------

// ShutdownMessage

// -------------------------------------------------------------------

// NoMasterDetectedMessage

// -------------------------------------------------------------------

// NewMasterDetectedMessage

// required string pid = 2;
inline bool NewMasterDetectedMessage::has_pid() const {
  return _has_bit(0);
}
inline void NewMasterDetectedMessage::clear_pid() {
  if (pid_ != &_default_pid_) {
    pid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& NewMasterDetectedMessage::pid() const {
  return *pid_;
}
inline void NewMasterDetectedMessage::set_pid(const ::std::string& value) {
  _set_bit(0);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void NewMasterDetectedMessage::set_pid(const char* value) {
  _set_bit(0);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void NewMasterDetectedMessage::set_pid(const char* value, size_t size) {
  _set_bit(0);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewMasterDetectedMessage::mutable_pid() {
  _set_bit(0);
  if (pid_ == &_default_pid_) {
    pid_ = new ::std::string;
  }
  return pid_;
}

// -------------------------------------------------------------------

// GotMasterTokenMessage

// required string token = 1;
inline bool GotMasterTokenMessage::has_token() const {
  return _has_bit(0);
}
inline void GotMasterTokenMessage::clear_token() {
  if (token_ != &_default_token_) {
    token_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GotMasterTokenMessage::token() const {
  return *token_;
}
inline void GotMasterTokenMessage::set_token(const ::std::string& value) {
  _set_bit(0);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void GotMasterTokenMessage::set_token(const char* value) {
  _set_bit(0);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void GotMasterTokenMessage::set_token(const char* value, size_t size) {
  _set_bit(0);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GotMasterTokenMessage::mutable_token() {
  _set_bit(0);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  return token_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace internal
}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
